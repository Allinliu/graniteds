:imagesdir: ./images

[[graniteds.remoting]]
== Remoting and serialization

ifdef::flex[]
Data serialization between a Flex client application and a Java EE server may use three kinds of transfer encodings:
 
* XML (HttpService)
* SOAP (WebService)
* AMF3 (RemoteObject)

According to all available benchmarks, the last option, AMF3 with +RemoteObject+, is the faster and most efficient. Additionally it allows to work with 
strongly typed objects in the Flex application and thus is more maintainable. GraniteDS provides a full implementation of the AMF3 protocol and a set 
of adapters suitable for remote calls to POJO, EJB 3, Seam, Spring, and Guice services. 

However, standard AMF serialization/deserialization does not provide any way, either with LiveCycle Data Services/BlazeDS or with GraniteDS, to transfer 
private or protected data fields. Only non-static, non-transient public fields, either those with public getter and setter or with a public declaration,  
are taken into account. This limitation applies to both Java and ActionScript 3 classes. 

To preserve strong and secure data encapsulation of your beans while serializing their private internal state - such as a version number in entity beans â€” 
GraniteDS provides a specific serialization mechanism called externalization. See <<remoting.externalization,corresponding section>> for details. 

Data serialization between a client application and a Java EE server may use different kinds of transfer encodings, including XML, JSON, Java serialization, or 
various other serialization frameworks. GraniteDS provides an implementation of the Adobe AMF3 (ActionScript Message Format) binary encoding which is very 
compact, fast and efficient. Other formats may be added later but AMF3 is a really easy-to-use and performant format. 

The AMF3 format allows for serialization of strongly typed objects. GraniteDS adds the concept of externalization to transform the serialized objects 
before and after they are serialized. This allows for example to serialize JPA entities without triggering initialization of all lazy properties.  
endif::flex[]

ifdef::java[]
When building a JavaFX client, you can then easily deserialize these entities to a properly JavaFX-bindable bean having the same properties. 
This way the client and server parts of the application are cleanly separated, the JavaFX bean does not have any dependency (even internal runtime) on 
the JPA provider and the JPA entity having no dependency on the JavaFX binding API.
endif::java[] 

*The AMF3 format*

AMF3 is a very compact binary format for data serialization/deserialization and remote method invocation. A key feature of this format is that it preserves 
the entire graph of your data without duplicating identical objects (contrary to JSON for example). For example, if A1 and A2 contain a reference to the same B1, 
the serialization of A1 and A2 does not duplicate B1.  The target client VM will contain exactly the same data graph with only one B1 referenced by one A1 and one A2.
Furthermore, there is no risk of infinite recursion if the data graph contains circular references. For example, if B1 contains the set of A# that references B1. 
AMF3 messages are sent as a part of a AMF0 envelope and body. GraniteDS implements an AMF3 serializer/deserializer and relies on some code borrowed 
from the link:$$http://sourceforge.net/projects/openamf/$$[OpenAMF] project for AMF0 serialization/deserialization. The AMF0 and AMF3 specifications are now public.
You may download them link:$$http://download.macromedia.com/pub/labs/amf/amf3_spec_121207.pdf$$[here]. You will need a Macromedia or Adobe account. 

*The JMF format*

TODO

ifdef::flex[]
[[remoting.remoteobject]]
=== Using the RemoteObject API

+RemoteObject+ is the standard remoting API of the Flex SDK. It can be use either declaratively in MXML or programmatically in ActionScript. 
A +RemoteObject+ is attached to a server-side destination, generally defined in the +services-config.xml+ (see the <<config.remotingservices,configuration reference>>). 
You can also refer to the link:$$http://livedocs.adobe.com/flex/3/html/help.html?content=data_access_4.html$$[Adobe Flex SDK documentation] about +RemoteObject+ 
to get some useful information. 

[[remoting.romxml]]
==== RemoteObject in MXML

For this example, we'll show a simple POJO destination : 

[source,java]
----
public class HelloService {

   	public String hello(String name) {
   		return "Hello " + name;	
   	}
}
----

[source,xml]
----
<services>
    <service
        id="granite-service"
        class="flex.messaging.services.RemotingService"
        messageTypes="flex.messaging.messages.RemotingMessage">
        <destination id="hello">
            <channels>
                <channel ref="graniteamf"/>
            </channels>
            <properties>
                <scope>request</scope>
                <source>com.myapp.HelloService</source>
            </properties>
        </destination>
    </service>
</services>

<channels>
    <channel-definition id="graniteamf" class="mx.messaging.channels.AMFChannel">
        <endpoint
            uri="http://{server.name}:{server.port}/{context.root}/graniteamf/amf"
            class="flex.messaging.endpoints.AMFEndpoint"/>
    </channel-definition>
</channels>
----

This service configuration defines an AMF channel and a simple POJO destination named _hello_ mapped to this channel and which source is the Java class 
we have created. POJO is the default service adapter so we don't have to specify a particular service factory. 

[source,xml]
----
<?xml version="1.0"?>
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml">

    <mx:Script>
        import mx.rpc.events.ResultEvent;
        import mx.rpc.events.FaultEvent;
        import mx.controls.Alert;
        
        public function resultHandler(event:ResultEvent):void {
            // Display received message
            outputMessage.text = event.result as String;
        }                       
        
        public function faultHandler(event:FaultEvent):void {
            // Show error alert
            Alert.show(event.fault.faultString);               
        }
    </mx:Script>
	
    <!-- Connect to a service destination.--> 
    <mx:RemoteObject id="helloService" 
        destination="hello"
        result="handleResult(event);"
        fault="handleFault(event);"/>
	
    <!-- Provide input data for calling the service. --> 
    <mx:TextInput id="inputName"/>
	
    <!-- Call the web service, use the text in a TextInput control as input data.--> 
    <mx:Button click="helloService.hello(inputName.text)"/>
	
    <!-- Display results data in the user interface. --> 
    <mx:Label id="outputMessage"/>
</mx:Application>
----

This demonstrates a very simple remote call with basic +String+ data types. The destination defined in the MXML +RemoteObject+ declaration should match 
the destination name in +services-config.xml+.  

It is very important to note that remote calls in Flex are always _asynchronous_. The reason is that the Flash VM is not multithreaded and remote calls 
should not block user interaction. Something like +outputMessage.text = helloService.hello(inputName.text)+ will thus not work, and it is needed to 
attach event listeners to the +RemoteObject+ to handle the remote results and faults.		 

The actual return value of a remote call on a +RemoteObject+ is an +AsyncToken+ object. The MXML syntax +result+ and +fault+ is simply a shorthand 
for adding listeners to this token object. 

In this short example, there was only one method in the +RemoteObject+ so we could put the event listeners on the +RemoteObject+ itself. 
For services having more than one method, we would rather add a different event listener for each method : 

[source,xml]
----
<mx:RemoteObject id="helloService" 
        destination="hello">
    <mx:operation name="hello" 
        result="handleResult(event);"
        fault="handleFault(event);"/>
    <mx:operation name="..."
        result="..."
        fault="..."/>
</mx:RemoteObject>
----

The last but interesting way of handing the remote result is to bind the +AsyncToken+ property +lastResult+ to some UI component in MXML. The following code 
does the same thing than the initial example :  

[source,xml]
----
<?xml version="1.0"?>
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml">

    <!-- Connect to a service destination.--> 
    <mx:RemoteObject id="helloService" destination="hello"/>
    
    <!-- Provide input data for calling the service. --> 
    <mx:TextInput id="inputName"/>
    
    <!-- Call the web service, use the text in a TextInput control as input data.--> 
    <mx:Button click="helloService.hello(inputName.text)"/>
    
    <!-- Display results data in the user interface using binding on the lastResult property of AsyncToken. --> 
    <mx:Label id="outputMessage" text="{helloService.hello.lastResult}"/>
</mx:Application>
----

It is possible to use more complex data types as arguments or as result values. It is then necessary to create an equivalent ActionScript 3 class for each 
Java data class. You can refer to the <<remoting.mapping,mapping>> section to see how to do this in detail. Also see how you can use the 
<<graniteds.gas3,Gas3 code generator>> to do this for you. 

[source,java]
----
package com.myapp.model;

public class Person {

	private String name;

	public String getName() { 
		return name; 
	}
	public void setName(String name) { 
		this.name = name;
	}
}
----

[source,actionscript]
----
package com.myapp.model {
		
	[RemoteClass(alias="com.myapp.model.Person")]
	public class Person {
		public var name:String;
	}
}
----

[source,java]
----
public class PeopleService {

   	public List<Person> findAll(Person examplePerson) {
   		...
   		return list;	
   	}
}
----

[source,xml]
----
<?xml version="1.0"?>
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml">

    <!-- Connect to a service destination.--> 
    <mx:RemoteObject id="peopleService" 
        destination="people"
        result="handleResult(event);"
        fault="handleFault(event);"/>
	
    <!-- Provide input data for calling the service. --> 
    <mx:TextInput id="inputName"/>
	
    <!-- Call the web service, use the text in a TextInput control as input data.--> 
    <mx:Button click="peopleService.findAll(inputName.text)"/>
	
    <!-- Display results data in the user interface. --> 
    <mx:DataGrid id="outputGrid" dataProvider="{peopleService.lastResult}"/>
</mx:Application>
----

[[remoting.roactionscript]]
==== RemoteObject in ActionScript

Using +RemoteObject+ programmatically is necessary when called from a client controller class in a classic MVC pattern. 

[source,actionscript]
----
package com.myapp.controllers {

 	import mx.rpc.events.ResultEvent;
 	import mx.rpc.events.FaultEvent;
 	import mx.rpc.remoting.mxml.RemoteObject;
 	import mx.controls.Alert;

	public class HelloController {

		private var helloService:RemoteObject;

		public function HelloController():void {
            // Initialize a remote destination
            helloService = new RemoteObject("pojo");
            helloService.addEventListener(ResultEvent.RESULT, resultHandler, false, 0, true);
            helloService.addEventListener(FaultEvent.FAULT, faultHandler, false, 0, true);
        }
        
        private function resultHandler(event:ResultEvent):void {
            // Handler result
        }                       
        
        private function faultHandler(event:FaultEvent):void {
            // Handle fault
        }
    }
}
----

[[remoting.manualremoteobject]]
==== RemoteObject in ActionScript without +services-config.xml+ file

When there is no +services-config.xml+ (for example when the configuration is defined in the Spring or Seam configuration files),  it is necessary 
to manually initialize the endpoint for the +RemoteObjects+. 

[source,actionscript]
----
package com.myapp.controllers {

 	import mx.rpc.events.ResultEvent;
 	import mx.rpc.events.FaultEvent;
 	import mx.rpc.remoting.mxml.RemoteObject;
 	import mx.controls.Alert;

	public class HelloController {

		private var helloService:RemoteObject;

 		public function HelloController():void {
			// Initialize a remote destination
			helloService = new RemoteObject("hello");
			helloService.source = "com.myapp.HelloService";
			// Setup the channel set and endpoint for the RemoteObject 
			helloService.channelSet = new ChannelSet();
			helloService.channelSet.addChannel(new AMFChannel("graniteamf", 
			     "http://{server.name}:{server.port}/myapp/graniteamf/amf"));
			helloService.addEventListener(ResultEvent.RESULT, resultHandler, false, 0, true);
			helloService.addEventListener(FaultEvent.FAULT, faultHandler, false, 0, true);
		}
        
		private function resultHandler(event:ResultEvent):void {
			// Handle result
		}                       
        
		private function faultHandler(event:FaultEvent):void {
			// Handle fault
		}
    }
}
----

[[remoting.rohttps]]
==== Using HTTPS

Using HTTPS involves two steps :
 
* Configure a +SecureAMFChannel+ instead of an +AMFChannel+ in +services-config.xml+
* Configure a SSL endpoint in +web.xml+

.+services-config.xml+
[source,xml]
----
<services>
    ...
</services>

<channels>
    <channel-definition id="graniteamf" class="mx.messaging.channels.SecureAMFChannel">
        <endpoint
            uri="https://{server.name}:{server.port}/{context.root}/graniteamf/amf"
            class="flex.messaging.endpoints.AMFEndpoint"/>
    </channel-definition>
</channels>
----

.+web.xml+
[source,xml]
----
<security-constraint>
    <display-name>AMF access</display-name>
    <web-resource-collection>
        <web-resource-name>Secure AMF remoting</web-resource-name>
        <description>Secure AMF Remoting</description>
        <url-pattern>/graniteamf/*</url-pattern>
    </web-resource-collection>
    <auth-constraint>
        <role-name>role1</role-name>
        ...
    </auth-constraint>
    <user-data-constraint>
        <transport-guarantee>CONFIDENTIAL</transport-guarantee>
    </user-data-constraint>
</security-constraint>
----
endif::flex[]

ifdef::java[]
[[remoting.remoteservice]]
==== RemoteService API

Here is an example on how to execute a remote call on a GraniteDS enabled service. 

[source,java]
----
public class HelloController {

	private RemoteService helloService;

	public HelloController() {
		ApacheAsyncTransport transport = new ApacheAsyncTransport();
		transport.start();

		AMFRemotingChannel channel = new AMFRemotingChannel(transport, "my-graniteamf", 
			new URI("http://localhost:8080/helloworld/graniteamf/amf.txt"));
		RemoteService srv = new RemoteService(channel, "hello");
		
		srv.newInvocation("sayHello", args[0]).setTimeToLive(5, TimeUnit.SECONDS)
			.addListener(new ResultFaultIssuesResponseListener() {
			         
   			@Override
   			public void onResult(ResultEvent event) {
       			System.out.println("Result: " + event.getResult());
 	   		}

   			@Override
   			public void onFault(FaultEvent event) {
       			System.err.println("Fault: " + event.toString());
   			}

   			@Override
   			public void onIssue(IssueEvent event) {
       			System.err.println("Issue: " + event.toString());
   			}
		}).invoke();
	}
}
----

The first step consists in initializing the HTTP client implementation that will be used. The default built-in transport implementation +ApacheAsyncTransport+ 
uses the Apache asynchronous HTTP client, so you just have to create and start this transport. 

The second step consists in defining the remote channel endpoint, i.e. the server url to which the client will connect. +AMFRemotingChannel+ is the default 
implementation of a remoting channel that uses the AMF3 protocol and format. 

Finally you can create a +RemoteService+ which is basically a client for a particular remote service. It requires the name of the destination (which 
semantics depends on the target server framework, it can be the name of a Spring bean or the partial name of an EJB). 

Once the +RemoteService+ is initialized, you can execute remote calls through a "fluent" API by creating an invocation with +newInvocation+ and adding 
result/fault listeners with +addListener+ 

The listener has to implement the interface +ResponseListener+ which has 5 methods:
 
* onResult
* onFault
* onFailure
* onTimeout
* onCancelled

The first is obvious, the 4 others are different kinds of erroneous conditions. +onFault+ corresponds to an application or server exception, 
whereas +onFailure+, +onTimeout+ and +onCancelled+ correspond to network or connection error conditions. 

As this can be painful to implement those 5 methods for each call, the convenient abstract class +ResultFaultIssuesResponseListener+ merges the 3 last errors 
conditions in one single +onIssue+ handler. 

[[remoting.remoteservice.https]]
==== Using HTTPS

Using HTTPS involves two steps :
 
* Use a HTTPS url in the channel endpoint definition (you may have to do additional configuration to use certificates, see the doc of Apache HTTP client)
* Configure a SSL endpoint in +web.xml+

.+web.xml+
[source,xml]
----
<security-constraint>
    <display-name>AMF access</display-name>
    <web-resource-collection>
        <web-resource-name>Secure AMF remoting</web-resource-name>
        <description>Secure AMF Remoting</description>
        <url-pattern>/graniteamf/*</url-pattern>
    </web-resource-collection>
    <auth-constraint>
        <role-name>role1</role-name>
        ...
    </auth-constraint>
    <user-data-constraint>
        <transport-guarantee>CONFIDENTIAL</transport-guarantee>
    </user-data-constraint>
</security-constraint>
----
endif::java[]

ifdef::flex[]
[[remoting.tideremoting.flex]]
=== Using the Tide API

The Tide remoting API is an alternative to the standard +RemoteObject+. It can be used only programmatically in +ActionScript+ and simplifies the 
handling of asynchronicity by hiding +AsyncToken+ and other internal objects. Note that Tide provides much more than just a different API, it will be detailed
in the next chapters. 

[NOTE]
====
This section describes the usage of the Tide API with a standard AMF provider. When the Tide API is used in conjunction with GraniteDS and Tide-enabled server 
framework adapters, there are some specificities that are described in the chapters concerning each framework integration (<<ejb3.tide,EJB3>>, 
<<spring.tide,Spring>>, <<seam2.tide,Seam 2>>, <<cdi.tide,CDI>>). 
====

[[remoting.tidebasic.flex]]
==== Basic remoting

Let's see the same hello example with Tide. Note the usage of the Tide context object which represents the client application container.                       

[source,xml]
----
<?xml version="1.0"?>
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml">
    <mx:Script>
        import org.granite.tide.Tide;
        import org.granite.tide.Context;
        import org.granite.tide.events.TideResultEvent;
        import org.granite.tide.events.TideFaultEvent;
        
        private var tideContext:Context = Tide.getInstance().getContext();
        
        private function hello(name:String):void {
            // tideContext.helloService implicitly creates a proxy for the remote destination named helloService
            tideContext.helloService.hello(name, resultHandler, faultHandler);
        }
        
        private function resultHandler(event:TideResultEvent):void {
            outputMessage.text = event.result as String;
        }                       
        
        private function faultHandler(event:TideFaultEvent):void {
            // Handle fault
        }
    </mx:Script>
    
    <!-- Provide input data for calling the service. --> 
    <mx:TextInput id="inputName"/>
    
    <!-- Call the web service, use the text in a TextInput control as input data.--> 
    <mx:Button click="hello(inputName.text)"/>
    
    <!-- Result message. --> 
    <mx:Label id="outputMessage"/>
</mx:Application>
----

[[remoting.tidebasicdi.flex]]
==== Basic remoting with dependency injection

This example can be cleaned up by using the dependency injection feature of the Tide framework (see <<tide.remoting,here>> for more details). 
Basically you can inject a client proxy for a remote destination with the annotation +\[In\]+. 

[source,xml]
----
<?xml version="1.0"?>
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml"
    creationComplete="Tide.getInstance().initApplication()">
    <mx:Script>
        import org.granite.tide.Tide;
        import org.granite.tide.events.TideResultEvent;
        import org.granite.tide.events.TideFaultEvent;
        
        [In]
        public var helloService:Component;
        
        private function hello(name:String):void {
            helloService.hello(name, resultHandler, faultHandler);
        }
        
        private function resultHandler(event:TideResultEvent):void {
            outputMessage.text = event.result as String;
        }                       
        
        private function faultHandler(event:TideFaultEvent):void {
            // Handle fault
        }
    </mx:Script>
    
    <!-- Provide input data for calling the service. --> 
    <mx:TextInput id="inputName"/>
    
    <!-- Call the web service, use the text in a TextInput control as input data.--> 
    <mx:Button click="hello(inputName.text)"/>
    
    <!-- Result message. --> 
    <mx:Label id="outputMessage"/>
</mx:Application>
----

[[remoting.tideresponder.flex]]
==== Using the ITideResponder interface

In some cases, you may need to pass some value to the result/fault handler to be able to distinguish different calls on the same method. 
You can then implement the +ITideResponder+ interface or use the default +TideResponder+ implementation that is able to hold a token object: 

[source,actionscript]
----
public function call():void {
    var responder1:TideResponder = new TideResponder(helloResult, helloFault, "firstCall");
    var responder2:TideResponder = new TideResponder(helloResult, helloFault, "secondCall");
    tideContext.helloWorld.sayHello("Jimi", responder1);
    tideContext.helloWorld.sayHello("Jimi", responder2);
}

private function helloResult(event:TideResultEvent, token:Object):void {
    if (token == "firstCall")
        Alert.show(event.result);
}
----

In this case, the +Alert+ will show up only once for the first call. 

[[remoting.tideasync.flex]]
==== Simplifying asynchronous interactions

The +ITideResponder+ interface has another important use : it makes possible to provide a return object that will be merged  with the server result. 
It greatly helps working with the asynchronous nature of Flex remoting by limiting the need for result handlers. 

[source,actionscript]
----
private var products:ArrayCollection = new ArrayCollection();

public function call():void {
    tideContext.productService.findAllProducts(
        new TideResponder(resultHandler, null, null, products)
    );
}

private function resultHandler(event:TideResultEvent):void {
   trace("Assert result was merged: " + (event.result === products));
}
----

[source,xml]
----
<mx:DataGrid dataProvider="{products}">
   ...
</mx:DataGrid>
----

The result of the remote call will be merged in the provided products collection instance. It is thus necessary to provide a non null object instance, 
and this kind of merge will work with real objects and collections but not with simple types (such as +String+, +Number+, ...).
Note that trying to merge a managed entity will work only if the received entity has the same +uid+ than the source entity. This is a normal behaviour to avoir 
breaking existing object associations in the local context. So this merge feature is mostly suitable for retrieving collections so you are sure that the same 
instance of the collection is kept in sync.  

[[remoting.tideserviceinit.flex]]
==== Service initializer

Tide remoting can be used without needing the standard +services-config.xml+ Flex configuration file. In this case, it is necessary to manually define 
the remoting channels. 

The easiest way is to setup the built-in default +DefaultServiceInitializer+ component implementation in the Tide context, for example in the +creationComplete+ 
of the main application. 

[source,actionscript]
----
Tide.getInstance().addComponentWithFactory("serviceInitializer", DefaultServiceInitializer, 
    { contextRoot: "/context-root" }
);
----

It is also possible to define +serverName+, +serverPort+ and alternative url mappings for Granite AMF remoting and for Gravity push +graniteUrlMapping+ 
and +gravityUrlMapping+. 

Tide additionally provides a built-in +DefaultSecureServiceInitializer+ with the same options to setup a +https+ channel. 

Finally you can completely customize the channel initialization by providing your own implementation of +IServiceInitializer+. 
It has only one method +initialize+ that is called for all ++RemoteObject++s or ++Consumer++s of the application. 

[[remoting.tideintercept.flex]]
==== Client message interceptors

If you need some common behaviour for all remote calls, such as showing/hiding a wait screen at each call or setting custom headers,  you can implement a 
message interceptor that will be called before and after each remote call or message. 

[source,actionscript]
----
public class MyMessageInterceptor implements IMessageInterceptor {
    public function before(msg:IMessage):void {
        showWaitScreen();
        msg.headers['customHeader'] = 'test';
    }

    public function after(msg:IMessage):void {
        var customHeader:String = msg.headers['customHeader'] as String;
        hideWaitScreen();
    }
}
----

[[remoting.tideexception.flex]]
==== Global exception handling

The server exceptions can be handled on the client-side by defining a fault callback on each remote call. It works fine but it is very tedious
 and you can always forget a case, in which case the error will be either ignored or result in a Flex error popup that is not very elegant. 

To help dealing with server exceptions, it is possible to define common handlers for particular fault codes on the client-side, and exception converters 
on the server-side, to convert server exceptions to common fault codes. 

On the server, you have to define an +ExceptionConverter+ class. For example we could write a converter to handle the JPA +EntityNotFoundException+ 
(in fact there is already a built-in converter for all JPA exceptions): 

[source,actionscript]
----
public class EntityNotFoundExceptionConverter implements ExceptionConverter {

    public static final String ENTITY_NOT_FOUND = "Persistence.EntityNotFound";
    
    public boolean accepts(Throwable t, Throwable finalException) {
        return t.getClass().equals(javax.persistence.EntityNotFoundException.class);
    }

    public ServiceException convert(
        Throwable t, String detail, Map<String, Object> extendedData) {

        ServiceException se = new ServiceException(
            ENTITY_NOT_FOUND, t.getMessage(), detail, t
        );
        se.getExtendedData().putAll(extendedData);
        return se;
    }
}
----

This class will intercept all +EntityNotFound+ exceptions on the server-side, and convert it to a proper +$$ENTITY_NOT_FOUND$$+ fault event. 

The argument +finalException+ contains the deepest throwable in the error and can be used to check if some higher level exception converter should 
be used to handle the exception. For example, the +HibernateExceptionConverter+ checks if the exception is wrapped in a +PersistenceException+, 
in which case it lets the JPA +PersistenceExceptionConverter+ accept the exception. 

This exception converter has to be declared on the GDS server config:
 
* When using +scan="true"+ in +granite-config.xml+, ensure that there is a +META-INF/granite-config.properties+ file (even empty) in the jar containing 
    the exception converter class. 
* When not using automatic scan, you can add this in +granite-config.xml+ : 
+
[source,xml]
----
<exception-converters>
  <exception-converter type="com.myapp.custom.MyExceptionConverter"/>
</exception-converters>
----
 
On the Flex side, you then have to define an exception handler class: 

[source,actionscript]
----
public class EntityNotFoundExceptionHandler implements IExceptionHandler {

    public function accepts(emsg:ErrorMessage):Boolean {
        return emsg.faultCode == "Persistence.EntityNotFound";
    }

    public function handle(context:BaseContext, emsg:ErrorMessage):void {
        Alert.show("Entity not found: " + emsg.message);
    }
}
----

... and register it as an exception handler for the Tide context in a static initializer block to be sure it is registered before anything else happens. 

[source,xml]
----
<mx:Application>
    <mx:Script>
        Tide.getInstance().addExceptionHandler(EntityNotFoundExceptionHandler);
    </mx:Script>
</mx:Application>
----

[[remoting.tidemisc.flex]]
==== Miscellaneous features

There are a few other features that are useful when working with remote services :
 
* The static property +Tide.showBusyCursor+ can enable or disable the busy mouse cursor during execution of remote calls. 
* +Tide.busy+ is a bindable property that can be used to determine if there is currently a remote call in progress. 
* +Tide.disconnected+ is a bindable property that can be used to determine if the network connection is currently broken. 
    If becomes false when a network error is detected and set to true after each successful call. 

endif::flex[]

ifdef::java[]
[[remoting.tideremoting.java]]
===Using the Tide API

The Tide remoting API is an alternative to the low-level +RemoteService+ API that simplifies the handling of asynchronicity and brings much more features 
that will be described in the next chapters. 

[NOTE]
====
This section describes the usage of the Tide API with a standard AMF provider. When the Tide API is used in conjunction with GraniteDS and Tide-enabled 
server framework adapters, there are some specificities that are described in the chapters concerning each framework integration (<<ejb3.tide,EJB3>>,  
<<spring.tide,Spring>>, <<cdi.tide,CDI>>). 
====

[[remoting.tidebasic.java]]
==== Basic remoting

Let's see the same hello example with Tide. Note the usage of the Tide context object which reprensents the client application container.                       

[source,java]
----
public class HelloExample {

    public static void main(String[] args) {
    
    	ContextManager contextManager = new SimpleContextManager(new DefaultApplication());
    	Context context = contextManager.getContext();
    	
    	ServerSession serverSession = context.set(new ServerSession("/myapp", "localhost", 8080));
    	serverSession.start();
    	
    	Component helloService = context.set("helloService", new ComponentImpl(serverSession));
    	
    	// Asynchronous call using handlers
    	helloService.call("sayHello", "Barack", new TideResponder<String>() {
    		@Override
    		public void result(TideResultEvent<String> result) {
    			System.out.println("Async result: " + result.getResult());
    		}
    		
    		@Override
    		public void fault(TideFaultEvent fault) {
    			System.err.println("Fault: " + fault.getFault());
    		}
    	};
    	
    	// Synchronous wait of Future result
    	Future<String> futureResult = helloService.call("sayHello", "Barack");
    	String result = futureResult.get();
    	System.out.println("Sync result: " + result);
    }
----

This is a bit different than the +RemoteService+ API. It looks like a mostly cosmetic changes, but there are many internal things that differ. 

The core of the Tide framework is the context which contains the various elements of the application. Here we create a simple +ContextManager+ which 
implements a very minimalistic built-in application container. For more demanding environment, we recommend using the +SpringContextManager+ which will 
use a Spring application container or the +CDIContextManager+ which will use a CDI/Weld SE container.  

The +Application+ SPI is a simple interface that allows integrating the Tide context with the client UI framework. For example, JavaFX requires that all UI 
operations are executed in the main UI thread. The JavaFX application implementation will ensure that the asynchronous result handlers of remote calls will 
be executed in the UI thread so you can do whatever UI operation you need using the received data. This is also necessary as Tide will merge the received
data with local objects which might possibly have data bindings with UI components.

The +ServerSession+ encapsulates all communication between the client application and the remote services for a particular server endpoint. 
Note that here it has to be "attached" manually to the Tide context with +context.set()+. In a Spring environment, it would just have to be declared as a Spring bean.  

Finally the +Component+ instance represents a client proxy to the actual remote service. The method +call+ executes the remote call and returns a +Future+ 
object which can be used to get the result. It is also necessary to provide a last argument to the method +call+ which can implement +TideResponder+ 
and +result+, +fault+. Here we use an untyped +ComponentImpl+ implementation but it's also possible to generate typesafe client proxies from the service interfaces. 

[[remoting.tidebasicdi.java]]
==== Basic remoting with dependency injection

The previous example was a bit basic, and in more realistic applications you might want to use the client proxies from some controller class instead 
of the main application. For a more 'enterprisy' usage, we might configure a Spring container on the client application. 

.Example Spring client configuration
[source,java]
----
package com.myapp.client;

@Configuration
public class Config {
	
	@Bean
	public SpringEventBus eventBus() {
		return new SpringEventBus();
	}
	
	@Bean
	public SpringContextManager contextManager(SpringEventBus eventBus) {
		return new SpringContextManager(new JavaFXPlatform(eventBus));
	}
	
	@Bean(initMethod="start", destroyMethod="stop")
	public ServerSession serverSession() throws Exception {
		return new ServerSession("spring", "/test", "localhost", 8080);
	}
	
	@Bean
	public Component helloService(ServerSession serverSession) {
		return new ComponentImpl(serverSession);
	}
	
	@Bean(initMethod="start")
	public App app() {
		return new App();
	}
}
----

.Main application
[source,java]
----
package com.myapp.client;

public class App {

	public static void main(String[] args) {
    	ApplicationContext applicationContext = new AnnotationConfigApplicationContext();
    	applicationContext.scan("com.myapp.client");
    	applicationContext.refresh();
    	applicationContext.registerShutdownHook();
    	applicationContext.start();
	}
	
	@Inject @Qualifier("helloService")
	private Component helloService;
	
	public void start() {
    	helloService.call("sayHello", "Barack", new TideResponder<String>() {
    		@Override
    		public void result(TideResultEvent<String> result) {
    			System.out.println("Async result: " + result.getResult());
    		}
    		
    		@Override
    		public void fault(TideFaultEvent fault) {
    			System.err.println("Fault: " + fault.getFault());
    		}
    	};
	}
}
----

Here we use the Spring Java configuration mechanism, but you could also do all this in XML or any other Spring configuration style. 
The important things here are that we declared two components of types +EventBus+ and +ContextManager+, and the +ServerSession+ and a +Component+ as Spring beans. 
Once everything is properly wired together, you can simply inject the client proxies in whatever bean you want to execute the remote calls. 

[[remoting.tideresponder.java]]
==== Using the TideResponder Interface

In some cases, you may need to pass some value to the result/fault handler to be able to distinguish different calls on the same method. You can then 
override the default +TideResponder+ implementation and store a token object: 

[source,java]
----
public static class HelloResponder implements TideResponder {

	private final String token;

	public HelloResponder(String token) {
		this.token = token;
	}
	
	@Override
	public void result(TideResultEvent event) {
		System.out.println("Result for " + token + ": " + event.getResult());
	}
	
	@Override
	public void fault(TideFaultEvent event) {
		System.err.println("Fault for " + token + ": " + event.getFault());
	}
}

public void call() {
	helloService.call("sayHello", "Barack", new HelloResponder("firstCall"));
	helloService.call("sayHello", "Barack", new HelloResponder("secondCall"));
}
----

In this case, there will be two outputs for each token. Note that as everything is asynchronous, the order of the results is undefined. 

[[remoting.tideasync.java]]
==== Simplifying asynchronous interactions

The +TideMergeResponder+ interface is an extension of +TideResponder+ that makes possible to provide a return object that will be merged 
with the server result. It helps working with the asynchronous nature of remoting by limiting the need for result handlers. 

[source,java]
----
private List<Product> products = new ArrayList<Product>();

public function call():void {
    productService.findAllProducts(new TideMergeResponder<List<Product>>() {
		@Override
		public void result(TideResultEvent<List<Product>> event) {
			System.out.println("Result was merged: " + (event.getResult() == products));
		}
		
		@Override
		public void fault(TideFaultEvent event) {
			System.err.println("Fault for " + token + ": " + event.getFault());
		}
		
		@Override
		public List<Product> getMergeResultWith() {
			return products;
		}
    });
}
----

This may not seem very useful in this case, but when combined with a data binding mechanism such as the one in JavaFX, that means that you don't have to 
handle the actual result. By using a JavaFX +ObservableList+ The binding would transparently propagate all incoming remote data to the UI. 
Note that this kind of automatic merge will work correcly only with mutable objects (so no +String+, +Number+, ...). It is generally the most useful with collections. 

[[remoting.tideexception.java]]
==== Global exception handling

The server exceptions can be handled on the client-side by defining a fault callback on each remote call. It works fine on a case by case basis but 
it is very tedious  and you can always forget a case, in which case the error will be either ignored or result in a global error popup that is not very elegant. 

To help dealing with server exceptions, it is possible to define common handlers for particular fault codes on the client-side, and exception converters 
on the server-side, to convert server exceptions to common fault codes. 

On the server, you have to define an +ExceptionConverter+ class. For example we could write a converter to handle the JPA  +EntityNotFoundException+ 
(in fact there is already a built-in converter for all JPA exceptions): 

[source,java]
----
public class EntityNotFoundExceptionConverter implements ExceptionConverter {

    public static final String ENTITY_NOT_FOUND = "Persistence.EntityNotFound";
    
    public boolean accepts(Throwable t, Throwable finalException) {
        return t.getClass().equals(javax.persistence.EntityNotFoundException.class);
    }

    public ServiceException convert(
        Throwable t, String detail, Map<String, Object> extendedData) {

        ServiceException se = new ServiceException(
            ENTITY_NOT_FOUND, t.getMessage(), detail, t
        );
        se.getExtendedData().putAll(extendedData);
        return se;
    }
}
----

This class will intercept all +EntityNotFound+ exceptions on the server-side, and convert it to a  proper +$$ENTITY_NOT_FOUND$$+ fault event. 

The argument +finalException+ contains the deepest throwable in the error and can be used to check if some higher level  exception converter should 
be used to handle the exception. For example, the +HibernateExceptionConverter+ checks if the exception is wrapped in a +PersistenceException+, in which 
case it lets the JPA +PersistenceExceptionConverter+ accept the exception. 

This exception converter has to be declared on the GDS server config : 

*  When using +scan="true"+ in +granite-config.xml+, ensure that there is a +META-INF/granite-config.properties+ file (even empty) in the jar containing 
the exception converter class. 
*  When not using automatic scan, you can add this in +granite-config.xml+ : 
+
----
<exception-converters>
  <exception-converter type="com.myapp.custom.MyExceptionConverter"/>
</exception-converters>
----
 
On the client side, you then have to define an exception handler class: 

[source,java]
----
public class EntityNotFoundExceptionHandler implements ExceptionHandler {

    public boolean accepts(FaultMessage emsg) {
        return "Persistence.EntityNotFound".equals(emsg.getCode());
    }

    public void handle(Context context, FaultMessage emsg, TideFaultEvent faultEvent) {
        System.err.println("Entity not found: " + emsg.getMessage());
    }
}
----

... and register it as an exception handler in the Tide context. That is simply declare it as a managed bean with +context.set(new EntityNotFoundExceptionHandler())+ 
or as a Spring bean when using Spring. 
endif::java[]

ifdef::flex[]
[[remoting.mapping.flex]]
=== Mapping Java and AS3 objects

When using typed objects, it's necessary to create an ActionScript 3 class for each Java class that will be marshalled between Flex and Java. However due 
to the differences of data types in the ActionScript 3 and Java languages, data conversions are done during serialization/deserialization. 
GraniteDS follows the standard conversions specified in the Adobe Flex SDK documentation link:$$http://livedocs.adobe.com/flex/3/html/data_access_4.html#244138$$[here], 
with an important exception : GDS will neither convert AS3 +String+ to Java numeric types or +boolean+, nor AS3 numeric types or +boolean+ to +String+. 
You must use AS3 numeric types for Java numeric types and AS3 boolean type for Java boolean types; either primitive or boxed boolean. 

+long+, +Long+, +BigInteger+ and +BigDecimal+ values may by converted to their respective ActionScript 3 equivalent 
(see <<graniteds.bignumber,Big Number Implementations>> for details). 
endif::flex[]

ifdef::java[]
[[remoting.mapping.java]]
=== Mapping between client and server Java objects

The server data objects are usually defined as JPA entities. Using them directly on the client is possible but requires having a runtime dependency
on the JPA provider on the client, which may not be practical or suitable at all. This is for example what would happen by using standard Java serialization. 
Additionally, using a JPA entity on a JavaFX client (for example) means that your data beans will not benefit from all the data binding machinery of JavaFX 
which requires the use of special properties implementations (++javafx.beans.property.Property++). You could probably build a 'dual' Java class which is both 
a JPA entity and a bindable JavaFX bean but that would imply a very tight coupling between the client and the server (and a dependency of the server application
on JavaFX !!) and might at last not work at all (in particular for collection properties). 

Having two different classes for the same data object on the client and the server is thus a cleaner approach and simply requires some tooling to automatically
generate one from the other. GraniteDS provides a JPA/JavaBean to JavaFX class generator which handles exactly this task. 
endif::java[]

ifdef::flex[]
[[remoting.externalization]]
=== Externalizers and AS3 code generation

In some cases it can be necessary to serialize private fields of a Java class (for example the +@Version+ field of a JPA entity). Due to the limited capabilities 
of the ActionScript 3 reflection API than cannot access private fields, it is necessary to create  an externalizable AS3 class 
(implementing +flash.utils.IExternalizable+ and its corresponding externalizable Java class. In both classes you have to implement two methods 
+readExternal+ and +writeExternal+ that read and write data to the network stream in the exact same order. 
This is extremely tedious and unmaintainable, so GraniteDS provides a specific mechanism to handle this almost transparently : 

* On the Java side, GraniteDS can simulate an externalizable class by using Java reflection, so there is no need to implement the interface 
    +java.io.Externalizable+ manually. You just have to configure which classes should be processed. 
* On the Flex side, the Gas3 generator can automatically generate the +writeExternal+ and +readExternal+ methods. 

By means of these two combined mechanisms, it's possible to serialize any kind of object with minimal effort.  

[[remoting.extjpaexample.flex]]
==== Example of a JPA entity and its corresponding AS3 beans

Let's say we have a basic entity bean that represents a person. The following code shows its implementation using JPA annotations: 

[source,java]
----
package com.myapp.entity;

import java.io.Serializable;

import javax.persistence.Basic;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Version;

@Entity
public class Person implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id @GeneratedValue
    private Integer id;

    @Version
    private Integer version;

    @Basic
    private String firstName;

    @Basic
    private String lastName;

    public Integer getId() {
        return id;
    }

    public String getFirstName() {
        return firstName;
    }
    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }
    public void setLastName(String lastName) {
        this.lastName = lastName;
    }
}
----

This simple entity bean has one _read-only_ property (++id++), one __completely private property__ (++version++) and two __read/write__ 
properties (++firstName++,  ++lastName++). With standard serialization, we would not be able to send the ++id++ and ++version++ fields to 
the Flex client code. One solution would be to make them public with getters and setters, but this would obviously expose these fields to manual 
and erroneous modifications. Another solution would be to make the person bean implement ++java.io.Externalizable++ instead of 
++java.io.Serializable++, but it would require implementing and maintaining the ++readExternal++ and ++writeExternal++ methods.
This is at least an annoyance, a source of errors, and might even be impossible if you do not have access to the source code to the Java entities. 

With GraniteDS automated externalization and without any modification made to our bean, we may serialize all properties of the +Person+ class, 
private or not. Furthermore, thanks to the Gas3 code generator, we do not even have to write the ActionScript 3 bean by ourselves. 
Here is a sample generated bean implementation: 

[source,actionscript]
----
/**
 * Generated by Gas3 v3.0.0 (Granite Data Services).
 *
 * WARNING: DO NOT CHANGE THIS FILE. IT MAY BE OVERWRITTEN EACH TIME YOU USE
 * THE GENERATOR. INSTEAD, EDIT THE INHERITED CLASS (Person.as).
 */

package com.myapp.entity {

    import flash.utils.IDataInput;
    import flash.utils.IDataOutput;
    import flash.utils.IExternalizable;
    import org.granite.collections.IPersistentCollection;
    import org.granite.meta;

    use namespace meta;

    [Bindable]
    public class PersonBase implements IExternalizable {

        private var __initialized:Boolean = true;
        private var __detachedState:String = null;

        private var _firstName:String;
        private var _id:Number;
        private var _lastName:String;
        private var _version:Number;

        meta function isInitialized(name:String = null):Boolean {
            if (!name)
                return __initialized;

            var property:* = this[name];
            return (
                (!(property is Person) || (property as Person).meta::isInitialized()) &&
                (!(property is IPersistentCollection) ||
                  (property as IPersistentCollection).isInitialized())
            );
        }

        public function set firstName(value:String):void {
            _firstName = value;
        }
        public function get firstName():String {
            return _firstName;
        }

        public function get id():Number {
            return _id;
        }

        public function set lastName(value:String):void {
            _lastName = value;
        }
        public function get lastName():String {
            return _lastName;
        }

        public function readExternal(input:IDataInput):void {
            __initialized = input.readObject() as Boolean;
            __detachedState = input.readObject() as String;
            if (meta::isInitialized()) {
                _firstName = input.readObject() as String;
                _id = function(o:*):Number {
                    return (o is Number ? o as Number : Number.NaN) } (input.readObject());
                _lastName = input.readObject() as String;
                _version = function(o:*):Number {
                    return (o is Number ? o as Number : Number.NaN) } (input.readObject());
            }
            else {
                _id = function(o:*):Number {
                    return (o is Number ? o as Number : Number.NaN) } (input.readObject());
            }
        }

        public function writeExternal(output:IDataOutput):void {
            output.writeObject(__initialized);
            output.writeObject(__detachedState);
            if (meta::isInitialized()) {
                output.writeObject(_firstName);
                output.writeObject(_id);
                output.writeObject(_lastName);
                output.writeObject(_version);
            }
            else {
                output.writeObject(_id);
            }
        }
    }
}
----

This AS3 bean reproduces all properties found in the Java entity, public and private and even includes two extra properties, 
(++$$__initialized$$++ and ++$$__detachedState$$++), that correspond the the JPA internal state for lazy loading. Note that these two fields are present 
because the Gas3 generator has detected that our class is a JPA entity annotated with ++@Entity++. For simple Java beans, these two fields would not be 
present, but this shows that the pluggable externalizer mechanism in GraniteDS allows to do a lot more than simply serializing public data and value objects. 

Note that property accessors (++get++/++set++) are exactly the same as those found in the Java entity bean, and while all fields are serialized between 
the client and the server,  only ++firstName++ and ++lastName++ are modifiable in ActionScript 3 and ++id++ is kept read-only. 

[NOTE]
====
With the externalizer mechanism in GraniteDS, serializing data between Flex and Java is almost as powerful and flexible as pure Java serialization
between a Java client and a Java server. 
====
endif::flex[]

ifdef::java[]
[[remoting.extjpaexample.java]]
==== Example of a JPA entity and its corresponding JavaFX bean

Let's say we have a basic entity bean that represents a person. The following code shows its implementation using JPA annotations: 

[source,java]
----
package com.myapp.entity;

import java.io.Serializable;

import javax.persistence.Basic;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Version;

@Entity
public class Person implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id @GeneratedValue
    private Integer id;

    @Version
    private Integer version;

    @Basic
    private String firstName;

    @Basic
    private String lastName;

    public Integer getId() {
        return id;
    }

    public String getFirstName() {
        return firstName;
    }
    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }
    public void setLastName(String lastName) {
        this.lastName = lastName;
    }
}
----

With GraniteDS automated externalization and without any modification made to our bean, we may serialize all properties of the +Person+ JPA entity, 
and convert them to a +Person+ JavaFX bean. Furthermore, thanks to the Gfx code generator, we do not even have to write the JavaFX bean by ourselves.
Here is a sample generated bean implementation: 

[source,java]
----
@Serialized
public class PersonBase implements Serializable {

    @SuppressWarnings("unused")
    private boolean __initialized__ = true;
    @SuppressWarnings("unused")
	private String __detachedState__ = null;
    
    @Id
	private ObjectProperty<Long> id = new SimpleObjectProperty<Long>(this, "id");
	@Uid
	private StringProperty uid = new SimpleStringProperty(this, "uid");
    @Version
	private ObjectProperty<Integer> version = new SimpleObjectProperty<Integer>(this, "version");
	private StringProperty firstName = new SimpleStringProperty(this, "firstName");
	private StringProperty lastName = new SimpleStringProperty(this, "lastName");
	
	public ObjectProperty<Long> idProperty() {
		return id;
	}
    public Long getId() {
        return id.get();
    }
        
    public StringProperty uidProperty() {
    	return uid;
    }
    public void setUid(String value) {
        uid.set(value);
    }
    public String getUid() {
        return uid.get();
    }
    
	public ObjectProperty<Integer> versionProperty() {
		return version;
	}
    public Integer getVersion() {
        return version.get();
    }
    
    public StringProperty firstNameProperty() {
    	return firstName;
    }
    public void setFirstName(String value) {
        firstName.set(value);
    }
    public String getFirstName() {
        return firstName();
    }
    
    public StringProperty lastNameProperty() {
    	return lastName;
    }
    public void setLastName(String value) {
        lastName.set(value);
    }
    public String getLastName() {
        return lastName.get();
    }
}
----

This JavaFX bean reproduces all properties found in the JPA entity, public and private and even includes some extra properties and features, 
(++$$__initialized__$$++ and ++$$__detachedState__$$++), that correspond the the JPA internal state for lazy loading. Note that these  two fields are present 
because the Gfx generator has detected that our class is a JPA entity annotated with ++@Entity++. For simple Java beans, these two fields would not be present, 
but this shows that the pluggable externalizer mechanism in GraniteDS allows to do a lot more than simply serializing public data and value objects. 

With the externalizer mechanism in GraniteDS, serializing data between the client and the server is almost as powerful as pure Java serialization 
and additionally allows to maintain a clean decoupling between the client and server applications by using an intermediary binary format that is independent
of the actual class implementation, whatever framework is used on both sides. 
endif::java[]

[[remoting.extconfig]]
==== Standard configuration

In order to externalize the +Person.java+ entity bean, we must tell GraniteDS which classes we want to externalize with a special rule in the 
+granite-config.xml+ file: 

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE granite-config PUBLIC
    "-//Granite Data Services//DTD granite-config internal//EN"
    "http://www.graniteds.org/public/dtd/3.0.0/granite-config.dtd">

<granite-config>
    <class-getter type="org.granite.hibernate.HibernateClassGetter"/>

    <externalizers>
        <externalizer type="org.granite.hibernate.HibernateExternalizer">
            <include type="com.myapp.entity.Person"/>
        </externalizer>
    </externalizers>
</granite-config>
----

This instructs GraniteDS to externalize all classes named +com.myapp.entity.Person+ by using the +org.granite.hibernate.HibernateExternalizer+. 
Note that the +HibernateClassGetter+ configuration is necessary to detect Hibernate proxies (lazy-initialized beans). 
See more about this feature in the <<remoting.jpa,JPA and lazy initialization>> section. 

If you use an abstract entity bean as a parent to all your entity beans you could use this declaration, but note that +type+ in the example above 
is replaced by ++instance-of++: 

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE granite-config PUBLIC
    "-//Granite Data Services//DTD granite-config internal//EN"
    "http://www.graniteds.org/public/dtd/3.0.0/granite-config.dtd">

<granite-config>
    <class-getter type="org.granite.hibernate.HibernateClassGetter"/>

    <externalizers>
        <externalizer type="org.granite.hibernate.HibernateExternalizer">
            <include instance-of="com.myapp.entity.AbstractEntity"/>
        </externalizer>
    </externalizers>
</granite-config>
----

This will avoid the need of writing externalization instructions for all your beans, and all instances of +AbstractEntity+ will be automatically externalized. 

You may also use an +annotated-with+ attribute as follows: 

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE granite-config PUBLIC
    "-//Granite Data Services//DTD granite-config internal//EN"
    "http://www.graniteds.org/public/dtd/3.0.0/granite-config.dtd">

<granite-config>
    <class-getter type="org.granite.hibernate.HibernateClassGetter"/>

    <externalizers>
        <externalizer type="org.granite.hibernate.HibernateExternalizer">
            <include annotated-with="javax.persistence.Entity"/>
            <include annotated-with="javax.persistence.MappedSuperclass"/>
            <include annotated-with="javax.persistence.Embeddable"/>
        </externalizer>
    </externalizers>
</granite-config>
----

Of course, you may mix these different attributes as you want. Note, however, that there are precedence rules for these three configuration options: 
+type+ has precedence over +annotated-with+ and +annotated-with+ has precedence over +instance-of+. 
Playing with rule precedence provides a way to override general rules with more specific rules for particular classes. 

[[remoting.extscan]]
==== Autoscan configuration

Instead of configuring externalizers with the above method, you may use the autoscan feature: 

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE granite-config PUBLIC
    "-//Granite Data Services//DTD granite-config internal//EN"
    "http://www.graniteds.org/public/dtd/3.0.0/granite-config.dtd">

<granite-config scan="true"/>	        
----

With this very short configuration, GraniteDS will scan at startup all classes available in the classpath, actually all classes found in the classloader 
of the +GraniteConfig+ class, and discover all externalizers (classes that implements the GDS +Externalizer+ interface). 
The matching rule are defined implicitly by each externalizer, for example the Hibernate externalizer is defined to match all classes annotated with +@Entity+. 

[[remoting.extbuiltin]]
==== Built-in externalizers

GraniteDS comes with a set of built-in externalizers for the most usual kinds of Java classes:
 
* ++org.granite.messaging.amf.io.util.externalizer.DefaultExternalizer++: this externalizer may be used with any POJO bean. 
* ++org.granite.messaging.amf.io.util.externalizer.EnumExternalizer++: this externalizer may be used with Java +enum+ types. 
    When autoscan is enabled, it will be automatically used for all +enum+ types. 
* ++org.granite.hibernate.HibernateExternalizer++: This externalizer may be used with all JPA/Hibernate entities (i.e., all classes annotated 
    with +@Entity+, +@MappedSuperclass+ or +@Embeddable+ annotations). Include +granite-hibernate.jar+ in your classpath in order to use this feature. 
* ++org.granite.toplink.TopLinkExternalizer++: this externalizer may be used with all JPA/TopLink entities (i.e., all classes annotated 
    with +@Entity+, +@MappedSuperclass+ or +@Embeddable+ annotations). Include +granite-toplink.jar+ in your classpath in order to use this feature. 
* ++org.granite.eclipselink.EclipseLinkExternalizer++: this externalizer will be used with the new version of TopLink (renamed EclipseLink). 
    Include +granite-eclipselink.jar+ in your classpath in order to use this feature. 
* ++org.granite.openjpa.OpenJpaExternalizer++: this externalizer may be used with all JPA/OpenJPA (formerly WebLogic Kodo) entities. 
    Include +granite-openjpa.jar+ in your classpath in order to use this feature. 
* ++org.granite.datanucleus.DataNucleusExternalizer++: this externalizer may be used with all JPA/DataNucleus entities. 
    Include +granite-datanucleus.jar+ in your classpath in order to use this feature. 
* ++org.granite.tide.cdi.TideEventExternalizer++: this externalizer externalizes classes annotated with the +TideEvent+ annotation. 
* ++org.granite.messaging.amf.io.util.externalizer.LongExternalizer++: externalizes Java +long+ or +Long+ values. 
* ++org.granite.messaging.amf.io.util.externalizer.BigIntegerExternalizer++: externalizes Java +BigInteger+ values.
* ++org.granite.messaging.amf.io.util.externalizer.BigDecimalExternalizer++: externalizes Java +BigDecimal+ values.

ifdef::java[]
[[remoting.extbuiltin.client]]
==== Built-in client externalizers

GraniteDS provides support for JavaFX beans with the +org.granite.client.javafx.JavaFXExternalizer+ externalizer. It will unpack JavaFX properties 
and serialize them to a normalized network form.
endif::java[]             

[[remoting.extcustom]]
==== Custom externalizers

It is easy to write your own externalizer, you have to implement the +org.granite.messaging.amf.io.util.externalizer.Externalizer+ interface, or extend 
the +DefaultExternalizer+ class. There is no particular use case for this extension; it mostly depends on your specific needs  and you should look at 
the standard externalizer implementations to figure out how to write your custom code. 

If you use autoscan configuration, make sure your class is packaged in a jar accessible via the +GraniteConfig+ class loader (++granite-server.jar++ classpath),
put a ++META-INF/granite-config.properties++ in your jar, even empty, and put relevant code in the accept method to define which classes your externalizer 
should process: 

[source,java]
----
public int accept(Class<?> clazz) {
    return clazz.isAnnotationPresent(MySpecialAnnotation.class) ? 1 : -1;
}
----

You may, of course, use any kind of conditional expression, based on annotations, inheritance, etc. The returned value is a numeric weight used when GDS 
tries to figure out what externalizer it should use when it encounters a Java bean at serialization time: -1 means "do not use this externalizer", 
0 or more means "use this externalizer if there is no other externalizer that returns a superior weight for this bean". 
+DefaultExternalizer+ has a weight of 0, +EnumExternalizer+ and the built-in JPA externalizers a weight of 1. 
If your class would normally be externalized by the +HibernateExternalizer+, you may, for example,  use a weight of 2 when you want to replace the default 
serialization for some particular entities. 

[NOTE]
====
Creating your own externalizer generally means that you also need to write a corresponding template for the Gas3 generator with matching 
implementations of +readExternal+ and +writeExternal+. 
====

[[remoting.extmisc]]
==== +@ExternalizedBean+ and +@Include+

Two standard annotations are available that give you more control over the externalization process:

* ++@ExternalizedBean++: This class annotation may be used to instruct GDS to externalize the annotated bean with the +DefaultExternalizer+ 
    or any other externalizer specified in the type attribute. For example, you could annotate a Java class with:                 
+
[source,java]
----
@ExternalizedBean(type=path.to.MyExternalizer.class)
public class MyExternalizedBean {
    ...
}
----
*  ++@Include++: This method annotation may be used on a public getter when you want to externalize a property with no corresponding field 
    (i.e., a computed property). For example:                 
+
[source,java]
----
public class MyBean {

    private int value;

    ...

    @Include
    public int getSquare() {
        return value * value;
    }
}	        
----

ifdef::flex[]
Of course, this annotation will only be used if the +MyBean+ class is configured for externalization. Note that externalized properties are always 
read only: a +setSquare(...)+ will never be used in the client to server serialization. 
Note also that Gas3 uses this annotation when it generates ActionScript3 bean so you'll find an extra +square+ member field in your generated +MyBean.as+.
endif::flex[] 
ifdef::java[]
Of course, this annotation will only be used if the +MyBean+ class is configured for externalization. Note that externalized properties are always 
read only: a +setSquare(...)+ will never be used in the client to server serialization. Note also that Gfx uses this annotation when it generates 
Java/JavaFX bean so you'll find an extra +square+ member field in your generated +MyBean.java+.
endif::java[] 

[[remoting.classgetters]]
==== Custom class getters

A problem with the default AMF3 serialization is to get the true class name of an object in special cases. For example, a simple +myObject.getClass().getName()+ 
with a proxied entity bean would return +org.hibernate.proxy.HibernateProxy+ instead of the underlying entity bean class name. 
In order to get through this kind of problem, you must configure a class getter. Other methods of +ClassGetter+ are also used by Tide to determine 
some internal properties of the managed objects, such as their JPA internal initialization state.  

Class getters are generally used in conjunction with externalizers. For example, the full configuration for an application using Hibernate entities 
would be (without autoscan): 

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE granite-config PUBLIC
    "-//Granite Data Services//DTD granite-config internal//EN"
    "http://www.graniteds.org/public/dtd/3.0.0/granite-config.dtd">

<granite-config>
  <class-getter type="org.granite.hibernate.HibernateClassGetter"/>

  <externalizers>
    <externalizer type="org.granite.hibernate.HibernateExternalizer">
      <include instance-of="test.granite.ejb3.entity.AbstractEntity"/>
    </externalizer>
  </externalizers>
</granite-config>
----

The +org.granite.hibernate.HibernateClassGetter+ class is used in order to retreive the correct entity class name from a proxy. 
You may write and plug your own class getter in a similar way. 

[[remoting.instanciators]]
==== Instantiators

At deserialization time, from client to server, GraniteDS must instantiate and populate new JavaBeans with serialized data. The population issue 
(strictly private field), as we have seen before, is addressed by externalizers. But there is still a problem with classes that do not declare a default 
constructor. How do we instantiate those classes with meaningful parameters at deserialization time? 

When GraniteDS encounters classes without a default constructor, it tries to instantiate them by using the Sun JVM +sun.reflect.ReflectionFactory+ 
class that bypasses this limitation. Then, if it can successfully instantiate this kind of class, fields deserialization follows the standard process
with or without externalization. This solution has three serious limitations however: it only works with a Sun JVM, it does not take care of complex 
initialization you may have put in your custom contructor, and it cannot work with classes that should be created via a static factory method. 

With GraniteDS _instantiators_, you may control the instantiation process, delaying the actual instantiation of the class after all its serialized data 
has been read. 

*Built-in instantiators*

Two instantiators come with GDS: 

* ++org.granite.messaging.amf.io.util.instantiator.EnumInstantiator++: This instantiator is used in order to get an +Enum+ constant value from 
    an +Enum+ class and value (the +String+ representation of the constant), by means of the +java.lang.Enum.valueOf(Class<? extends Enum> enumType, String name)+ method. 

* ++org.granite.hibernate.HibernateProxyInstantiator++: It is used when GDS needs to recreate an +HibernateProxy+. See source code for details. 

Note that those instantiators do not require an entry in +granite-config.xml+, they are respectively used by the +EnumExternalizer+, +HibernateExternalizer+, 
and +TopLinkExternalizer+. 

*Custom instantiators*  

Let's say you have a JavaBean like this one: 

[source,java]
----
package org.test;

import java.util.Map;
import java.util.HashMap;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;

public class MyBean {

    private final static Map<String, MyBean> beans = new HashMap<String, MyBean>();

    private final String name;
    private final String encodedName;

    protected MyBean(String name) {
        this.name = name;
        try {
            this.encodedName = URLEncoder.encode(name, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }

    public static MyBean getInstance(String name) {
        MyBean bean = null;
        synchronized (beans) {
            bean = beans.get(name);
            if (bean == null) {
                bean = new MyBean(name);
                beans.put(name, bean);
            }
        }
        return bean;
    }

    public String getName() {
        return name;
    }

    public String getEncodedName() {
        return encodedName;
    }
}
----

With this kind of Java class, even with the help of the GDS +DefaultExternalizer+ and the Sun +ReflectionFactory+ facility, you will not be able to get 
the cached instance of your bean and the +encodedName+ field will not be correctly initialized. Instead, a new instance of +MyBean+ would be created 
with a simulated default constructor and the name field would be assigned with serialized data. 

The solution is to write a custom instantiator that will be used at deserialization time: 

[source,java]
----
package org.test;

import java.util.Collections;
import java.util.List;
import java.util.ArrayList;

import org.granite.messaging.amf.io.util.instantiator.AbstractInstanciator;

public class MyBeanInstanciator extends AbstractInstanciator<MyBean> {

    private static final long serialVersionUID = -1L;

    private static final List<String> orderedFields;
    static {
        List<String> of = new ArrayList<String>(1);
        of.add("name");
        orderedFields = Collections.unmodifiableList(of);
    }

    @Override
    public List<String> getOrderedFieldNames() {
        return orderedFields;
    }

    @Override
    public MyBean newInstance() {
        return MyBean.getInstance((String)get("name"));
    }
}
----

You should finally use a +granite-config.xml+ file as follows in order to use your instantiator: 

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE granite-config PUBLIC
    "-//Granite Data Services//DTD granite-config internal//EN"
    "http://www.graniteds.org/public/dtd/3.0.0/granite-config.dtd">

<granite-config>
  <externalizers>
    <externalizer type="org.granite.messaging.amf.io.util.externalizer.DefaultExternalizer">
      <include type="org.test.MyBean"/>
    </externalizer>
  </externalizers>

  <instanciators>
    <instanciator type="org.test.MyBean">org.test.MyBeanInstanciator</instanciator>
  </instanciators>
</granite-config>
----

[[remoting.jpa]]
=== JPA and lazy initialization

In many Java EE applications, persistence is done by using a JPA provider (such as Hibernate). The application directly persists and fetch Java entities, 
so this could seem natural to transfer these same objects to the client layer instead of adding a extra conversion layer with data transfer objects. 
However this is not as simple as it seems, in particular when using the lazy loading feature of JPA (and most applications using JPA should use lazy loading). 

Usual serialization providers (AMF or not) will either throw exceptions during serialization (because the lazy loaded associations are not available 
at this time), or load the complete object graph and thus limit the applicability of lazy loading (when using patterns such as __Open Session in View__). 

GraniteDS on the other hand is able to reliably serialize JPA entities with its externalizer mechanism (even detached objects outside of a JPA session) 
and supports both kinds of associations: _proxy_ (single-valued associations) and _collections_  (such as +List+, +Set+, +Bag+ and ++Map++). 
As described in the previous section, it provides built-in support for Hibernate, TopLink/EclipseLink, OpenJPA and DataNucleus. 

ifdef::flex[]
[NOTE]
====
It is important to note that as a JPA detached entity can be reliably serialized between Flex and Java, it's perfectly possible (and even recommended) 
to directly persist or merge entities sent from the Flex application without any intermediate DTO layer. 
====
endif::flex[]

ifdef::java[]
[NOTE]
====
It is important to note that as a JPA detached entity can be reliably serialized between the Java client and the Java EE service, it's perfectly possible 
(and even recommended) to directly persist or merge entities sent from the client application without any intermediate DTO layer. 
====
endif::java[]

[[remoting.jpasingle]]
==== Single-valued associations (proxied or weaved associations)

In your JPA entity bean, you may have a single-valued association like this: 

[source,java]
----
@Entity
public class MyEntity {

    @Id @GeneratedValue
    private Integer id;

    @OneToOne(fetch=FetchType.LAZY)
    private MyOtherEntity other;

    // Skipped code...
}

@Entity
public class MyOtherEntity {

    @Id @GeneratedValue
    private Integer id;

    // Skipped code...
}
----

If you load a large collection of +MyEntity+ and do not need other references, this kind of declaration prevents unnecessary performance and memory usage 
(please refer to Hibernate documention in order to actually fetch these references when you need them).  
With GDS, you can keep those uninitialized references as is. For example: 

ifdef::flex[]
[source,actionscript]
----
[Bindable]
[RemoteClass(alias="path.to.MyEntity"]
public class MyEntity {

    private var __initialized:Boolean = true;
    private var __detachedState:String = null;

    private var _id:Number;
    private var _other:MyOtherEntity;

    meta function isInitialized(name:String = null):Boolean {
        if (!name)
            return __initialized;

        var property:* = this[name];
        return (
            (!(property is Welcome) || (property as Welcome).meta::isInitialized()) &&
            (!(property is IPersistentCollection) ||
              (property as IPersistentCollection).isInitialized())
        );
    }

    // Skipped code...

    public override function readExternal(input:IDataInput):void {
        __initialized = input.readObject() as Boolean;
        __detachedState = input.readObject() as String;
        if (meta::isInitialized()) {
            _id = function(o:*):Number {
                return (o is Number ? o as Number : Number.NaN) } (input.readObject());
            _other = input.readObject() as MyOtherEntity;
            // read remaining MyEntity fields...
        }
        else
            _id = function(o:*):Number {
                return (o is Number ? o as Number : Number.NaN) } (input.readObject());
    }
}

[Bindable]
[RemoteClass(alias="path.to.MyOtherEntity"]
public class MyOtherEntity {

    private var __initialized:Boolean = true;
    private var __detachedState:String = null;

    private var _id:Number;

    // Skipped code...

    public override function readExternal(input:IDataInput):void {
        __initialized = input.readObject() as Boolean;
        __detachedState = input.readObject() as String;
        if (meta::isInitialized()) {
            _id = input.readObject() as int;
            // read remaining MyOtherEntity fields...
        }
        else
            _id = input.readObject() as int;
    }
}	        
----
endif::flex[]

ifdef::java[]
[source,java]
----
@Serialized
@RemoteAlias("path.to.MyEntity")
public class MyEntity {

    private boolean __initialized__ = true;
    private String __detachedState__ = null;

    private Long id;
    private MyOtherEntity _other;

    // Skipped code, getters/setters...
}

[Bindable]
[RemoteClass(alias="path.to.MyOtherEntity"]
public class MyOtherEntity {

    private boolean __initialized__ = true;
    private String __detachedState__ = null;

    private Long id;

    // Skipped code, getters/setters...
}           
----
endif::java[]

When the client deserializes your collection of ++MyEntity++'s with lazy loaded +MyOtherEntity+ references, it reads a +initialized+ flag set to +true+ 
when it encounters a +MyEntity+ instance since ++MyEntity++'s are all initialized; so it reads all +MyEntity+ fields including the +$$_other$$+ one.  
When it deserializes a +MyOtherEntity+ instance referenced by a +MyEntity+, it reads a +initialized+ flag set to +false+ since +MyOtherEntity+ is lazy loaded, 
so it only reads the +MyOtherEntity+ +id+. Informations put in +$$__initialized$$+, +$$__detachedState$$+ and +$$_id$$+ are sufficient to restore a 
correct +HibernateProxy+ instance when you give back +MyEntity+ objects to the server for update. 

ifdef::flex[]
[[remoting.jpacoll.flex]]
==== Collections (List, Set, Bag, Map)

GDS also provides a way to keep uninitialized collections as is. When the externalizer encounters an uninitialized collection, it does not try to serialize 
its content and marks it as uninitialized. This information is kept in client beans and  when this bean is sent back to the server (e.g., for an update), 
the externalizer restores a lazy initialized collection in Java. 
This gives you a good control over serialization depth, as you do not face the risk of serializing the entire graph of your data, and prevents faulty 
updates (i.e., an empty collection is saved and deletes database data while it was only uninitialized). 

For example, in this persistent set: 

[source,java]
----
package com.myapp.entity;

import java.util.HashSet;
import java.util.Set;

...
import javax.persistence.CascadeType;
import javax.persistence.FetchType;
import javax.persistence.OneToMany;

@Entity
public class Person extends AbstractEntity {
    ...
    @OneToMany(cascade=CascadeType.ALL, fetch=FetchType.LAZY, mappedBy="person")
    private Set<Contact> contacts = new HashSet<Contact>();
    ...
    public Set<Contact> getContacts() {
        return contacts;
    }
    public void setContacts(Set<Contact> contacts) {
        this.contacts = contacts;
    }
}

// code for Contact skipped...
----

[source,actionscript]
----
package com.myapp.entity {

    ...
    import mx.collections.ListCollectionView;

    [Bindable]
    [RemoteClass(alias="test.granite.ejb3.entity.Person")]
    public class Person implements IExternalizable {

        ...
        private var _contacts:ListCollectionView;
        ...
        public function set contacts(value:ListCollectionView):void {
            _contacts = value;
        }
        public function get contacts():ListCollectionView{
            return _contacts;
        }
        ...
        public override function readExternal(input:IDataInput):void {
            ...
            _contacts = input.readObject() as ListCollectionView;
            ...
        }
        public override function writeExternal(output:IDataOutput):void {
            ...
            output.writeObject(_contacts);
            ...
        }
    }

    // code for Contact skipped...
}
----

The actual, persistence aware, +mx.collections.ListCollectionView+ implementation is part of a GDS Flex library (++granite-essentials.swc++) that 
contains all AS3 classes you need in order to use the lazy loaded collections feature. 

If GDS encounters an uninitialized +Set+, it is serialized as a +org.granite.persistence.PersistentSet+ that contains some extra data indicating its 
initialization state. 

Other persistent collections, such as +List+, +Bag+, and +Map+, are handled in a similar manner. 

GDS/JPA uses +mx.core.IUID+ for all entity beans. See the the Hibernate forums https://community.jboss.org/wiki/EqualsAndHashCode[here] about 
+equals+/+hashCode+/collection problems and the use of UUIDs. This is only an implementation choice and you are free to code whatever you want. 
endif::flex[]

ifdef::java[]
[[remoting.jpacoll.java]]
==== Collections (List, Set, Bag, Map)

GDS also provides a way to keep uninitialized collections as is. When the externalizer encounters an uninitialized collection, it does not try to 
serialize its content and marks it as uninitialized. This information is kept in client beans and when this bean is sent back to the server 
(e.g., for an update), the externalizer restores a lazy initialized collection in Java. This gives you a good control over serialization depth, as 
you do not face the risk of serializing the entire graph of your data, and prevents faulty updates (i.e., an empty collection is saved and deletes 
database data while it was only uninitialized). 

For example, in this persistent set: 

[source,java]
----
package com.myapp.entity;

import java.util.HashSet;
import java.util.Set;

...
import javax.persistence.CascadeType;
import javax.persistence.FetchType;
import javax.persistence.OneToMany;

@Entity
public class Person extends AbstractEntity {
    ...
    @OneToMany(cascade=CascadeType.ALL, fetch=FetchType.LAZY, mappedBy="person")
    private Set<Contact> contacts = new HashSet<Contact>();
    ...
    public Set<Contact> getContacts() {
        return contacts;
    }
    public void setContacts(Set<Contact> contacts) {
        this.contacts = contacts;
    }
}

// code for Contact skipped...
----

[source,java]
----
package com.myapp.entity;

...
import javafx.collections.ObservableList;

@Serialized
@RemoteAlias("test.granite.ejb3.entity.Person")
public class Person implements Serializable {

    ...
	private ReadOnlyListWrapper<Contact> contacts = FXPersistentCollections.readOnlyObservablePersistentList(this, "contacts");
    ...
    public ReadOnlyListProperty<Contact> contactsProperty() {
        return contacts.getReadOnlyProperty();
    }        
    public ObservableList<Contact> getContacts() {
        return contacts;
    }
}

// code for Contact skipped...	        
----

The actual, persistence aware, +ObservableList+ implementation is part of a GDS JavaFX client library (++granite-client-javafx.jar++) that contains 
all you need in order to use the lazy loaded collections feature. 

If GDS encounters an uninitialized +Set+, it is serialized as a +org.granite.messaging.persistence.ExternalizablePersistentSet+ that contains some extra 
data indicating its intitialization state. Other persistent collections, such as +List+, +Bag+, and +Map+, are handled in a similar manner.  

GDS/JPA works best with a +uid+ field for all entity beans. See the the Hibernate forums https://community.jboss.org/wiki/EqualsAndHashCode[here] about 
+equals+/+hashCode+/collection problems and the use of UUIDs. This is only an implementation choice and you are free to code whatever you want. 
endif::java[]

[NOTE]
==== 
. With standard configuration (++scan++ set to ++false++), you must use the appropriate class getter together with the persistence externalizer 
    (eg. ++org.granite.openjpa.OpenJpaClassGetter++ with ++org.granite.openjpa.OpenJpaExternalizer++). 
. With all persistence externalizers, provided that you have added the relevant jar to your application classpath, you may use the auto scan feature: 
    <granite-config scan="true"> without anything else (no class getter or externalizer configuration): 
    your entities will be automatically externalized according to the underlying JPA engine. 
. If you put many persistence externalizers libraries in the same application, only the one corresponding to your JPA provider will be active. 
    This can be useful to build portable application between Java EE servers. If you bundle both +granite-hibernate.jar+ and +granite-eclipselink.jar+, 
    the application should work under both JBoss (which bundles Hibernate) and GlassFish v3 (which bundles EclipseLink).        
====

[[remoting.security]]
=== Securing remote destinations

ifdef::flex[]
Security in Flex applications cannot simply rely on standard +web-app+ +security-constraints+ configured in +web.xml+. 
Generally, you have only one +channel-definition+, equivalent to a +url-pattern+ in +web.xml+, and multiple destinations. So, the security must be 
destination-based rather than URL-pattern based, and Java EE standard configuration in +web.xml+ does not provide anything like that. 

With a configured +SecurityService+, you will be able to use ++RemoteObject++'s +setCredentials+, +setRemoteCredentials+ and +logout+ methods.
endif::flex[] 

ifdef::java[]
Security in a Java client cannot simply rely on standard +web-app+ +security-constraints+ configured in +web.xml+. 
Generally, you have only one +channel-definition+, equivalent to a +url-pattern+ in +web.xml+, and multiple destinations. So, the security must be 
destination-based rather than URL-pattern based, and Java EE standard configuration in +web.xml+  does not provide anything like that. 

With a configured +SecurityService+, you will be able to use ++Channel++'s +setCredentials+ and +logout+ methods.
endif::java[]

Another important feature in security is to be able to create and expose a +java.security.Principal+ to, for example, an EJB3 session bean backend 
so role-based security can be used. 

At this time, GraniteDS provides security service implementations for Tomcat5/6/7+, Jetty 6/7+, GlassFish V2+ and V3 and WebLogic 10+ servers. 
Because JBoss bundles Tomcat by default but may be configured to use Jetty instead, Tomcat or Jetty security services may work as well with JBoss. 

When you are using Java Enterprise frameworks such as Seam or Spring together with GraniteDS, you may use specific Seam Security or Spring Security 
implementations instead of the previous container-based services: please refer to <<graniteds.seam2,Seam Services>> 
or <<graniteds.spring,Spring Services>> for more information. 

[[remoting.secconfig]]
====Configuration

To enable security, you simply put this kind of declaration in your +granite-config.xml+ file:             

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE granite-config PUBLIC
    "-//Granite Data Services//DTD granite-config internal//EN"
    "http://www.graniteds.org/public/dtd/3.0.0/granite-config.dtd">
<granite-config>
    ...
    <security type="org.granite.messaging.service.security.TomcatSecurityService"/>
    <!--
    Alternatively for Tomcat 7.x
    <security type="org.granite.messaging.service.security.Tomcat7SecurityService"/>
    Alternatively for Jetty 6.x
    <security type="org.granite.messaging.service.security.Jetty6SecurityService"/>
    For Jetty 7.x/8.x (available at eclipse.org)
    <security type="org.granite.messaging.service.security.Jetty7SecurityService"/>
    For GlassFish 2.x
    <security type="org.granite.messaging.service.security.GlassFishSecurityService"/>
    For GlassFish 3.x
    <security type="org.granite.messaging.service.security.GlassFishV3SecurityService"/>
    For WebLogic
    <security type="org.granite.messaging.service.security.WebLogicSecurityService"/>
    -->
</granite-config>
----

Some of these implementations (currently only ++TomcatSecurityService++) accept an optional parameter. In the case of the Tomcat service, 
it's the name of the service that will be used to execute the authentication in case you have many services defined in your +server.xml+. 

.+granite-config.xml+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE granite-config PUBLIC
    "-//Granite Data Services//DTD granite-config internal//EN"
    "http://www.graniteds.org/public/dtd/3.0.0/granite-config.dtd">
<granite-config>
    ...
    <security type="org.granite.messaging.service.security.TomcatSecurityService">
        <param name="service" value="your-tomcat-service-name-here"/>
    </security>
</granite-config>        
----

You may now use role-based security on destination in your +services-config.xml+ file: 

.+services-config.xml+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<services-config>
    <services>
        <service id="granite-service"
            class="flex.messaging.services.RemotingService"
            messageTypes="flex.messaging.messages.RemotingMessage">
            <destination id="person">
                <channels>
                    <channel ref="my-graniteamf"/>
                </channels>
                <properties>
                    <scope>session</scope>
                    <source>com.myapp.PersonService</source>
                </properties>
                <security>
                    <security-constraint>
                        <auth-method>Custom</auth-method>
                        <roles>
                            <role>user</role>
                            <role>admin</role>
                        </roles>
                    </security-constraint>
                </security>
            </destination>

            <destination id="restrictedPerson">
                <channels>
                    <channel ref="my-graniteamf"/>
                </channels>
                <properties>
                    <scope>session</scope>
                    <source>com.myapp.RestrictedPersonService</source>
                </properties>
                <security>
                    <security-constraint>
                        <auth-method>Custom</auth-method>
                        <roles>
                            <role>admin</role>
                        </roles>
                    </security-constraint>
                </security>
            </destination>
        </service>
    </services>
    ...
</services-config>
----

Here, the +person+ destination can be used by authenticated users with +user+ or +admin+ roles, while the +restrictedPerson+ destination can only be 
used by authenticated users with the +admin+ role. 

Please refer to Tomcat and JBoss documentation for setting up your users/roles configuration. 

ifdef::flex[]
[[remoting.secro]]
==== +SecureRemoteObject+

When using the +RemoteObject+ API, the simplest way to use security in your Flex application is to use the +org.granite.rpc.remoting.mxml.SecureRemoteObject+ class.
This class brings advanced event-based security support as shown here:             

[source,actionscript]
----
...
import org.granite.rpc.remoting.mxml.SecureRemoteObject;
import org.granite.events.SecurityEvent;
...
private var srv:SecureRemoteObject = null;
...
public function init():void {
    srv = new SecureRemoteObject("mydestination");
    srv.addEventListener(SecurityEvent.ALL, onSecurityEvent);
    ...
}

public function onSecurityEvent(event:SecurityEvent):void {
    switch (event.type) {
    case SecurityEvent.INVALID_CREDENTIALS:
        // show message "wrong username or pasword"
        break;
    case SecurityEvent.NOT_LOGGED_IN:
        srv.logout(); // reset remote object
        // show login panel...
        break;
    case SecurityEvent.SESSION_EXPIRED:
        srv.logout(); // reset remote object
        // show login panel...
        break;
    case SecurityEvent.ACCESS_DENIED:
        // show message "you don't have rights..."
        break;
    }
}

public function onCredentialsSet(username:String, password:String):void {
    srv.setCredentials(username, password);
    ...
}

public function doLogout():void {
    srv.logout();
    ...
}
...
----

Note that you must compile your MXML/AS3 classes with the +granite.swc+ or +granite-flex45.swc+ library in order to use +SecureRemoteObject+.
endif::flex[]         

[[remoting.secdestination]]
==== Fine-grained per-destination security

You may write and configure a specific +RemoteDestinationSecurizer+ in order to add fine grained security checks for specific actions.  

[source,java]
----
public interface RemotingDestinationSecurizer extends DestinationSecurizer {

    public void canExecute(ServiceInvocationContext context)
        throws SecurityServiceException;
}
----

You then have to tell GraniteDS where to use your securizer: 

[source,xml]
----
<services-config>
    <services>
        <service ...>
            <destination id="restrictedDestination">
                ...
                <properties>
                    <securizer>path.to.MyDestinationSecurizer</securizer>
                </properties>
            </destination>
        </service>
    </services>
    ...
</services-config>
----

Note that securizers, if any, are always called before the standard +SecurityService.authorize()+ method.         

[[serialization.securizer]]
==== Deserialization protection

At Java side, AMF deserialization instantiates classes that are referenced in the binary-encoded request coming from the client. 
Thus, a malicious AMF3 request can be crafted in order to instantiate an arbitrary Java class (and execute its constructor and setters) 
that has nothing to do with the expected data exchanged between the client application and the server application. 

GraniteDS' fix for this security issue relies on a new configurable option that you can put in your +granite-config.xml+ file. 
If you don't configure anything, you will always see this warning at the startup of the application: 

----
WARN  [GraniteConfig] You should configure a deserializer securizer in your granite-config.xml file in order to prevent potential security exploits!
----

In order to secure your application, you are strongly encouraged to configure a securizer as follows: 

[source,xml]
----
<!DOCTYPE granite-config PUBLIC
  "-//Granite Data Services//DTD granite-config internal//EN"
  "http://www.graniteds.org/public/dtd/3.0.0/granite-config.dtd">
 
<granite-config scan="true">
 
  <amf3-deserializer-securizer param="
    org\.granite\..* |
    flex\.messaging\..* |
    com\.myapp\.entity\..*
  "/>
    
  ...
</granite-config>	       
----

By default, the securizer uses the +org.granite.messaging.amf.io.RegexAMF3DeserializerSecurizer+ class that, uses a regular expression parameter. 
Only classes whose name match one of theses patterns are allowed to be instantiated. Of course, all standard Java types are allowed by default and 
you don't have to explicitely add their package names expressions. 

If this default regex-based implementation doesn't fit your needs, you may write your own securizer implementation.
 It only has to implement the +org.granite.messaging.amf.io.AMF3DeserializerSecurizer+ interface and can be specified in ++granite-config.xml++: 

[source,xml]
----
<!DOCTYPE granite-config PUBLIC
  "-//Granite Data Services//DTD granite-config internal//EN"
  "http://www.graniteds.org/public/dtd/3.0.0/granite-config.dtd">
 
<granite-config scan="true">
 
  <amf3-deserializer-securizer type="com.myapp.MySecurizer"/>
  ...
</granite-config>
----
