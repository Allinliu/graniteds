:imagesdir: ./images

[[graniteds.gfx]]
== JavaFX Code Generator

[[gfx.overview]]
=== Overview

One of the main interests of using GraniteDS remoting is that is can maintain a strongly typed bindable JavaFX data model in the client application. 
However that implies that you have to write a specific JavaFX class for each Java class that will be serialized. Writing and maintaining these JavaFX beans 
is tedious and a source of many errors. In order to solve this problem and accelerate the development of JavaFX/Java EE applications, GraniteDS comes 
with an code generator that writes JavaFX beans for all Java beans.

Additionally this generator specifically supports the externalization mechanism of GraniteDS and is able to generate corresponding JavaFX classes 
for externalized Java beans (typically JPA/Hibernate entities) with specific templates.  

Finally this generator is able to write typesafe client proxies for exposed remote services. Compared to the +RemoteService+ API, this can greatly help 
development by bringing auto-completion and improved type-safety when using remote services.  

Gfx may also replicate validation annotations in order to use the client side validation framework (see <<graniteds.validation,Bean Validation (JSR-303)>>). 

The generator (named GFX) is implemented as an Ant task. This Ant task is packaged as an Eclipse 3.2+ Ant plugin but may also be used outside of Eclipse 
for command line Ant calls. It can also be used with Maven by using the Maven ant runner plugin.

[NOTE]
====
You may wonder why it is necessary let alone useful to generate Java classes from Java classes.
 
1. The JavaFX programming model is *very* different from JPA and you probably don't want a dependency on JPA on your client classes  
2. Using JPA classes on a Java/JavaFX client is possible but means that you need at least +persistence-api.jar+, and likely a full JPA provider jar on 
    your client app (to be able to deserialize proxies for example). This is probably not what you want.
3. We think it's much better to completely separate the client and server parts of the application and keep the dependencies where they have a meaning 
    (you probably don't want to try to persist JavaFX bindable entities with JPA).
====

[[gfx.classes]]
=== Generated JavaFX Classes

A common problem with code generators is the potential loss of manual modifications made in generated files. A generated file must be either generated 
once and only once, allowing for safe manual modifications, but it will not be able to reflect the modifications  made in its model (JavaBeans), or 
regenerated each time its model has been changed, thus preventing safe manual modifications. 

Gfx uses the principle of "Base" and customizable inherited classes that let you add methods to generated classes without facing the risk  of losing them 
when a new generation process is executed. For example, here are the two files generated for a given Java entity bean: 

.+Welcome.java+
[source,java]
----
package org.test;

import java.io.Serializable;

import javax.persistence.Basic;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Entity
public class Welcome implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id @GeneratedValue
    private Integer id;
    
    @Basic
    private String name;

    public Welcome() {
    }

    public Welcome(String name) {
        this.name = name;
    }
    
    public Integer getId() {
        return id;
    }

    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}
----

.+Welcome.java+
[source,java]
----
/**
 * Generated by Gfx v3.0.0 (Granite Data Services).
 *
 * NOTE: this file is only generated if it does not exist. You may safely put
 * your custom code here.
 */

package org.test.client;

@Serialized
@RemoteAlias("org.test.Welcome")
public class Welcome extends WelcomeBase {
}        
----

.+WelcomeBase.java+
[source,java]
----
/**
 * Generated by Gfx v3.0.0 (Granite Data Services).
 *
 * WARNING: DO NOT CHANGE THIS FILE. IT MAY BE OVERWRITTEN EACH TIME YOU USE
 * THE GENERATOR. INSTEAD, EDIT THE INHERITED CLASS (Welcome.as).
 */

package org.test.client;

@Serialized
public class WelcomeBase implements Serializable {
	...
}
----

The recommendations for manual editing are explicit in the header comments of each generated classes: while the "Base" class may be regenerated at any time, 
keeping it sync with its Java model class, the inherited one is only generated when it does not exist and you may safely add custom methods into it. 

This two files generation principle is used for all generated classes except interface and enum: these classes are generated without any "Base" class 
and overwritten each time you have modified their Java counterparts. 

[WARNING]
====
Do not modify manually generated client interface or enum classes! 
====

Here are the details for (re)generation conditions: 

Note that for Java classes, relevant timestamp is the last modified time of the .class file, not the .java file. 

[options="header"]
|===============
|Templates|Conditions for (re)generation
|Dual templates (base + inherited)|
    The inherited JavaFX class is generated only once if it does not exist. The JavaFX base one is generated if it does not exist 
    or if its timestamp (last modified time) is less than the Java class one
|Single template (enums or interfaces)|
    Like the base condition above, the JavaFX class is (re)generated if it does not exist or if its timestamp is less than the Java class one
|===============

[[gfx.templates]]
=== Java Classes and Corresponding Templates

Here is the summary of templates used by the generator depending on the kind of Java class it encounters: 

[options="header"]
|===============
|Type of Java Class|Template|Base Template
|Standard Java beans|bean.gsp|beanBase.gsp
|JPA entities: all classes annotated with +@Entity+ and +@MappedSuperclass+|entity.gsp|entityBase.gsp
|Java enums|enum.gsp|(none)
|Java interfaces|interface.gsp|(none)
|Java services: all classes annotated with +@RemoteDestination+|remote.gsp|remoteBase.gsp
|Java events (CDI): all classes annotated with +@TideEvent+|bean.gsp|beanBase.gsp
|===============

Note that all these templates are bundled in the +granite-generator.jar+ archive, in the +org.granite.generator.javafx.template+ package and accessible 
as resources via the class loader. 

[[gfx.eclipse]]
=== Eclipse Plugin


*Installation* 

Use our dedicated update site +http://www.granitedataservices.com/public/update-site/+ with the "Install
New Software..." feature of Eclipse.

Alternatively, you can download +$$org.granite.builder-***.jar$$+ and drop it in your Eclipse +plugins+ directory,
making sure to remove any older versions. Then, restart Eclipse.

*Adding the GraniteDS Nature and Configuration Wizard*

The _Add GraniteDS Nature_ is available for any _open Java project_. When you want to use the builder with your Java project, 
right-click on the project in your Eclipse package explorer and select __Add GraniteDS Nature__:

image::gb1.jpg[]

This action should launch a configuration wizard, whose first step is to select Java source folders for which you want 
code generation (ie. JavaFX beans that mirror your server-side Java beans):     

image::gb2.jpg[]

You may select as many Java source folders as you want and configure specific filters and output directories for each of them.
Just select one of the _Included_, _Excluded_, or _Output_ subnodes  and click on the _Edit_ button.     

image::gb3.jpg[]

For inclusion/exclusion patterns, the syntax is similar to the Ant include/exclude ones in fileset and the following rules 
apply: 

* If you do not configure any exclusion and inclusion patterns, all Java classes in the folder are used for the generation.
* If a class is matched by an exclusion pattern, it will be ignored even if it is matched by another inclusion pattern. 

For example, the +$$**/*Service*.java$$+ pattern will match any Java class which contains the +Service+ string in its name and 
which is in any subdirectory of the selected source folders (see previous panel). 

Inclusion patterns let you specify arbitrary parameters which will be passed as a Map<String, String> to the concerned 
template (ie. the one which is handling the kind of Java file which matches the include pattern). 
For example, you can specify an include pattern as follow: +$$**/*Service*.java[param1=value1,param2=value2]$$+. 
In the template, for each file matching the +$$**/*Service*.java$$+ pattern, you will then have access to a specific 
variable named +fAttributes+, a map containing two keys "param1" and "param2", bound to their respective values "value1" 
and "values2". 

Note that this parameters feature is only available for the Eclipse builder (you can't use it with the Ant/Maven task). 

For each selected Java source folder you may also configure specific output directories: 

* ++Output Directory++: A directory relative to your project directory where generated JavaFX classes are put. The default
	is +as3+ and you will likely want to change it to +jfx+ (for example).
* ++Base Output Directory++: An optional directory relative to your project directory where so-called "Base" 
    generated JavaFX classes are put. If left empty, the output directory above is used for both "Base" and inherited 
    JavaFX classes. See <<gfx.classes,here>> for this distinction.

TIP: output directories and base output directories can be absolute or relative to the current project directory. If you
want to generate classes in another project, you can use a path like +$$../client-project/src$$+.
    
The next step in the wizard allows you to configure Java project dependencies. 
This is required when your Java classes make references to other classes declared in other Java projects. 
Clicking on the _Add project_ button will open a dialog that lists all other  __open Java projects which have 
the GraniteDS nature__:     

image::gb4.jpg[]

The next step is classpath configuration. If you do not use any custom classes in the _Options_ panel you do not need 
to change anything here since the classpath is automatically configured with your current selected source folders. 
In the following picture, the +helloworld/bin+ directory, where Eclipse compiles your Java source, is preselected, 
as well as all libraries in the build path (eg. Java runtime jars, +ejb3-persistence.jar+ and ++jboss-ejb3x.jar++):

image::gb5.jpg[]

The next panel lets you configure custom generation templates. Those templates are a mix of the JSP syntax and the 
link:$$http://groovy.codehaus.org$$[Groovy language]. If you need specific code generation, you may write your own 
template, select one template in the displayed tree, and click on the _Edit_ button:

image::gb6fx.jpg[]

In the above example, a +class:+ protocol is used because all standard templates are available in the classpath. 
Alternatively, you may use the +file:+ protocol to load your template from the filesystem. These templates can be 
specified either by using absolute paths (eg. ++file:/absolute/path/to/mytemplate.gsp++) or paths relative to your 
current Eclipse project root directory (eg. ++path/to/mytemplate.gsp++). 

On the right, in the _JavaFX_ section, your different options are:

* _Basic_: templates are configured for JavaFX applications that do not use the Tide framework, but just basic
	remoting / messaging features.

* _Tide_: templates are configured for Tide applications, with remote services that use
	<<remoting.tideremoting.java, Tide responders>>. 

WARNING: be sure to click either on the +Basic+ or the +Tide+ buttons in the _JavaFX_ section! Using the default
templates will cause the builder to generate Flex code instead of JavaFX code.

The last panel lets you configure various options:   

image::gb7fx.jpg[]

Some explanations: 

* ++UID Property Name++: the name of the Java field that contains this UID; use the same name in all your beans. 
	Default is to search for field named +uid+.
            
* ++TypeFactory Class++: You may use this option to configure a custom factory for special type support.
            
* ++EntityFactory Class++: You may use this option to configure a custom factory for special entity support. 
    Setting this field to +org.granite.generator.as3.BVEntityFactory+ is useful if you want to use the GraniteDS 
	validation framework. See <<graniteds.validation,Bean Validation (JSR-303)>> for details.
            
* ++RemoteDestinationFactory Class++: You may use this option to configure a custom factory for special service support. 
    You could for example implement a specific factory to analyze services for a particular framework.

* ++"Show debug informations in console"++: If enabled, Gfx will display more information during the generation process.

Just ignore all other options in _Flex only options_ section as they are irrelevant for JavaFX applications.            

When you have finished with the wizard, a first generation process will start and you should see something like this 
in the Eclipse console:     

image::gb10fx.jpg[]

*The GraniteDS Project Properties Panel* 

If you need to change your configuration later, you can right-click on your project, select the _Properties_ item, 
and you'll be able to modify all GraniteDS Eclipse Builder configuration options: 

image::gb8.jpg[]

The panels are exactly the same as those of the wizard and the above documentation applies. 

*Removing the GraniteDS Nature*  

When you have configured your project to use the GraniteDS Eclipse Builder, you may cancel any further generation processes by removing the nature:

image::gb9.jpg[]

Note that the hidden configuration file +.granite+ in your project is not removed by this action and you must delete it manually. 
Otherwise, it will be reused whenever you add the nature again. 


*Java file deletion / renaming*

The main purpose of the builder is to generate JavaFX files based on Java sources which are added or modified. When a Java source file is deleted or renamed, 
the builder will append to the name of all potentially JavaFX generated files a suffix composed of a dot, the current system millisecond since epoch (1/1/1970) 
and an additional extension ".hid". The idea behind these renaming operations is to make sure that the Java compilation will detect errors if these classes are 
used in the project (easing refactoring) and to ensure that any manual editing you have made in these classes is recoverable. 



[[gfx.ant]]
=== Ant Task

*Installation in Eclipse*

See the <<gfx.eclipse, Eclipse plugin installation>> above.

The +gfx+ Ant task is now ready to be use in any of your +build.xml+ files under Eclipse and without declaring a
specific Ant task with +taskdef+. 

*Standalone Installation*

Extract the +tools+ folder from the distribution in a directory (say +gfxlibs+ at the root of you harddrive). 

In your +build.xml+, you must declare the Gfx ant task as follows: 

[source,xml]
----
<taskdef name="gfx" classname="org.granite.generator.javafx.AntJavaFXTask"/>	   
----

To launch a build process with Gfx targets, you should go to your Java source root directory and type something like: 

----
$ ant -lib /gfxlibs -f build.xml {target}
...
----

Just replace {target} with a valid target name and make sure Ant is correctly set up: set +$$ANT_HOME$$+ variable  and put +$$&<ANT_HOME>;/bin$$+ in 
your +PATH+ environment variable. 

*Basic Usage* 

After installation, you may use the Gfx Ant task in any target of an Ant build file. 

For example: 

.+build.xml+
[source,xml]
----
<target name="generate.fx">
    <gfx outputdir="java">
        <classpath>
            <pathelement location="classes"/>
        </classpath>
        <fileset dir="classes">
            <include name="com/myapp/entity/**/*.class"/>
        </fileset>
    </gas3>
</target>
----

As you can notice, Gfx generates JavaFX beans from JPA compiled classes. You may use multiple Ant filesets in order to specify for which JPA classes 
you want to generate JavaFX beans. The +classpath+ node is used for fileset class loading, and you may reference extra jars or classes needed 
by your beans class loading. 

The +outputdir+ attribute lets you instruct Gfx in which directory JavaFX beans will be generated (e.g., ++./java++). 
This path is relative to your current project directory and Gfx will create subdirectories for packages. JavaFX beans will by default have the same 
package hierarchy as Java classes, with the same subdirectories as well. This may not be very convenient, so it is recommended that you use a package 
translation definition (see below <<gfx.ant.packagetranslator,package translators>>). 

For each JPA entity (say ++com.myapp.entity.MyEntity++), Gfx will generate two JavaFX beans:
 
* ++org.entity.client.MyEntityBase.java++: This bean mainly contains fields, getters, setters, and extra methods.  
    This file is generated if it does not exist or if it is outdated. 
* ++org.entity.client.MyEntity.java++: This bean inherits from the "Base" one and is only generated if it does not exist. 

While you should not modify the "Base" file, since your modifications may be lost after another generation process,  you may safely add your code to the inherited bean. 

You can also use Ant ++zipfileset++s if you want to generate JavaFX classes from an existing jar. Note that the jar must be in the classpath: 

[source,xml]
----
<target name="generate.fx">
    <gfx outputdir="java">
        <classpath>
            <pathelement location="lib/myclasses.jar"/>
        </classpath>
        <zipfileset src="lib/myclasses.jar">
            <include name="com/myapp/entity/**/*.class"/>
        </zipfileset>
    </gas3>
</target>
----

[[gfx.ant.packagetranslator]]
*Packages Translations*

It is highly recommended that you tell Gfx to generate client classes with a different package and directory structure than the corresponding Java server classes. 
Using the same package can lead to classpath conflicts or ambiguous auto-completion in the IDE. 

[source,xml]
----
<gfx ...>
    <classpath .../>
    <fileset .../>

    <translator
        java="path.to.my.java.class"
        client="path.to.my.client.class" />
    <translator
        java="path.to.my.java.class.special"
        client="otherpath.to.my.client.class.special" />
  ...
</gfx>
----

Gfx uses these translators with a "best match" principle; all Java classes within the +path.to.my.java.class+ package, and subpackages as well, will be 
translated to +path.to.my.client.class+, while +path.to.my.java.class.special+  will use a specific translation (++otherpath.to.my.client.class.special++). 

*Groovy Templates*

Gfx generation relies on Groovy templates. You may plug your own templates in by using one of the advanced options attributes below.  
For example, you could add a +$$entitytemplate="/absolute/path/to/my/groovy/entityTemplate.gsp"$$+ attribute to the +gfx+ node. 
You can also specify paths to your custom templates relative to the current Ant project +basedir+ directory. 
If you want to see the Groovy code of the default templates, just unpack +granite-generator.jar+ in the +lib+ directory of the plugin, 
and look for +$$org/granite/generator/template/*[Base].gsp$$+ files. 

*Advanced Options (Gfx XML Attributes)*

Here is the complete list of Gfx node attributes:
 
* +outputdir+ and ++baseoutputdir++: We have already seen the +outputdir+ attribute  in basic usage. 
    +baseoutputdir+ lets you define a custom output directory for your "Base" generated files. 
    The default is to use the same directory as specified by the +outputdir+ attribute. 
* ++uid++: If you want your JavaFX to implement +Identifiable+, you must tell the generator the name of the Java field that contains this UID. 
    By default, Gfx will search for a field named +uid+. You may change this by adding a +uid="myUid"+ attribute to the +gfx+ node. 
    If Gfx does not find this +uid+, it will be silently ignored. 
* ++tide++: Should we use a Tide specific template instead of the standard base template used for entity beans (++true++ or ++false++, defaut is ++false++). 
    Setting this attribute has no effect if you use a custom entity base template. See below. 
* +entitytemplate+ and ++entitybasetemplate++: Templates used for classes annotated with +@Entity+ or +@MappedSuperclass+. 
* ++interfacetemplate++: Template used for Java interfaces. 
* +beantemplate+ and ++beanbasetemplate++: Templates used for other Java classes including +@Embeddable+. 
* ++enumtemplate++: Template used for +java.lang.Enum+ types. 
* +remotetemplate+ and ++remotebasetemplate++: Templates used for server services (EJB3, Spring or Seam services). 
* ++clienttypefactory++: You can plug your own +org.granite.generator.as3.As3TypeFactory+ implementation in order to add support for custom types. 
    For example, if you have configured a custom Joda time converter, you may extend Gfx accordingly for this custom type. 
    Just extend the +org.granite.generator.javafx.DefaultJavaFXTypeFactory+ class and return for example +com.myapp.custom.DATE+ 
    when you encounter a Joda +DateTime+ instance. See <<ext.customtypes,Handling custom data types>> for a detailed example. 
* ++entityfactory++: Class used to introspect specific entity properties or metadata (default is  ++org.granite.generator.as3.DefaultEntityFactory++). 
    You may also use the built-in +org.granite.generator.as3.BVEntityFactory+ in order to replicate bean validation annotations 
    into your AS3 model <<graniteds.validation,Bean Validation (JSR-303)>>. 
* ++remotedestinationfactory++: Class used to introspect specific service properties 
    or metadata (default is ++org.granite.generator.as3.DefaultRemoteDestinationFactory++). 
* ++transformer++: Class used to control the generation process (very advanced use). 
    Default for JavaFX is +org.granite.generator.javafx.JavaFXGroovyTransformer+.                  

For example: 

[source,xml]
----
<target name="generate.fx">
    <gfx
        outputdir="java"
        baseoutputdir="base_java"
        uid="myUidFieldName"
        entitytemplate="/myEntityTemplate.gsp"
        entitybasetemplate="/myEntityBaseTemplate.gsp"
        interfacetemplate="/myInterfaceTemplate.gsp"
        beantemplate="/myBeanTemplate.gsp"
        beanbasetemplate="/myBeanBaseTemplate.gsp"
        enumtemplate="/myEnumTemplate.gsp"
        remotetemplate="/myRemoteTemplate.gsp"
        remotebasetemplate="/myRemoteBaseTemplate.gsp"
        tide="true"
        clienttypefactory="path.to.MyCustomTypeFactory"
        entityfactory="path.to.MyEntityFactory"
        remotedestinationfactory="path.to.MyRDFactory"
        transformer="path.to.MyTransformer"
        externalizelong="true"
        externalizebiginteger="true"
        externalizebigdecimal="true">
        <classpath>
            <pathelement location="classes"/>
        </classpath>
        <fileset dir="classes">
            <include name="test/granite/ejb3/entity/**/*.class"/>
        </fileset>
    </gas3>
</target>
----

Note that when using a custom +clienttypefactory+, +entityfactory+, +remotedestinationfactory+  or +transformer+ attribute, you must configure the classpath 
in order to make your custom classes available to the Gfx engine; either use the +classpath+ attribute in the +taskdef+ declaration or in the +gfx+ call. 

[[gfx.templatelanguage]]
=== Template Language

See documentation for <<gas3.templatelanguage,Gas3 ActionScript 3 generator>>. 
