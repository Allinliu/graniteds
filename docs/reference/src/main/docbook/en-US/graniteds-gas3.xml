<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" []>
<chapter id="graniteds.gas3">
	<title>AS3 Code Generator</title>
    
	<section id="gas3.overview">
	   <title>Overview</title>
	   <para>
	   One of the main interests of using AMF remoting is that is can maintain a strongly typed data model in the Flex application. However that implies that
	   you have to write an AS3 class for each Java class that will be serialized.
	   Writing and maintaining these ActionScript 3 beans is tedious and a source of many errors. 
	   In order to solve this problem and accelerate the development of Flex/Java EE applications, GraniteDS comes with an ActionScript3 code generator that writes AS3 beans for all Java beans.
	   </para>
	   
	   <para>
	   Additionally this generator specifically supports the externalization mechanism of GraniteDS and is able to generate corresponding AS3 classes for externalized
	   Java beans (typically JPA/Hibernate entities) with specific templates. 
       </para> 
      
       <para>
       Finally this ActionScript 3 generator is able to write AS3 typed client proxies for exposed remote services. 
       Compared to the usual Flex <literal>RemoteObject</literal>, this can greatly help development by bringing auto-completion and improved type-safety in Flex 
       when using remote services. 
       </para>
       
       <para>
       Starting with GraniteDS 2.2, Gas3 may also replicate validation annotations in order to use the Flex side validation framework (see <link linkend="graniteds.validation">Bean Validation (JSR-303)</link>) 
       and may also be configured to generate <literal>Long</literal>, <literal>BigInteger</literal> and <literal>BigDecimal</literal> variable for their Java equivalents (see <link linkend="graniteds.bignumber">Big Number Implementations</link>).
       </para>
        
       <para>
       The generator (named GAS3) is implemented as an Eclipse plugin and as an Ant task. This Ant task is packaged as an Eclipse 3.2+ Ant plugin but may also be used outside of Eclipse for command line Ant calls.
       It is also included in the <ulink url="http://flexmojos.sonatype.org/">Flexmojos</ulink> Maven plugin. 
       </para>
        
       <para>
       The next sections introduce both the Eclipse plugin and Ant task configurations and usages. 
       You may also have a look at the Eclipse Plugins Installation section and at the Hello World revisited tutorial for a sample Eclipse Builder usage.
       </para>        
	</section>
	
	<section id="gas3.classes">
	   <title>Generated ActionScript 3 Classes</title>
	   <para>
	   A common problem with code generators is the potential loss of manual modifications made in generated files. 
	   A generated file must be either generated once and only once, allowing for safe manual modifications, but it will not be able to reflect the modifications 
	   made in its model (JavaBeans), or regenerated each time its model has been changed, thus preventing safe manual modifications.
	   </para>

       <para>        
       Gas3 uses the principle of "Base" and customizable inherited classes that let you add methods to generated classes without facing the risk 
       of losing them when a new generation process is executed. For example, here are the two files generated for a given Java entity bean:
       </para>

        <para><literal>Welcome.java</literal></para>
        <programlisting role="JAVA">
package org.test;

import java.io.Serializable;

import javax.persistence.Basic;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Entity
public class Welcome implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id @GeneratedValue
    private Integer id;
    
    @Basic
    private String name;

    public Welcome() {
    }

    public Welcome(String name) {
        this.name = name;
    }
    
    public Integer getId() {
        return id;
    }

    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}
        </programlisting>
 
        <para><literal>Welcome.as</literal></para>
        <programlisting role="AS3">
/**
 * Generated by Gas3 v2.2.0 (Granite Data Services).
 *
 * NOTE: this file is only generated if it does not exist. You may safely put
 * your custom code here.
 */

package org.test {

    [Bindable]
    [RemoteClass(alias="org.test.Welcome")]
    public class Welcome extends WelcomeBase {
    }
}
        </programlisting>
 
        <para><literal>WelcomeBase.as</literal></para>
        <programlisting role="AS3">
<![CDATA[/**
 * Generated by Gas3 v2.2.0 (Granite Data Services).
 *
 * WARNING: DO NOT CHANGE THIS FILE. IT MAY BE OVERWRITTEN EACH TIME YOU USE
 * THE GENERATOR. INSTEAD, EDIT THE INHERITED CLASS (Welcome.as).
 */

package org.test {

    import flash.utils.IDataInput;
    import flash.utils.IDataOutput;
    import flash.utils.IExternalizable;
    import org.granite.collections.IPersistentCollection;
    import org.granite.meta;

    use namespace meta;

    [Bindable]
    public class WelcomeBase implements IExternalizable {

        private var __initialized:Boolean = true;
        private var __detachedState:String = null;

        private var _id:Number;
        private var _name:String;

        meta function isInitialized(name:String = null):Boolean {
            if (!name)
                return __initialized;

            var property:* = this[name];
            return (
                (!(property is Welcome) || (property as Welcome).meta::isInitialized()) &&
                (!(property is IPersistentCollection) ||
                  (property as IPersistentCollection).isInitialized())
            );
        }

        public function get id():Number {
            return _id;
        }

        public function set name(value:String):void {
            _name = value;
        }
        public function get name():String {
            return _name;
        }

        public function readExternal(input:IDataInput):void {
            __initialized = input.readObject() as Boolean;
            __detachedState = input.readObject() as String;
            if (meta::isInitialized()) {
                _id = function(o:*):Number {
                    return (o is Number ? o as Number : Number.NaN) } (input.readObject());
                _name = input.readObject() as String;
            }
            else {
                _id = function(o:*):Number {
                    return (o is Number ? o as Number : Number.NaN) } (input.readObject());
            }
        }

        public function writeExternal(output:IDataOutput):void {
            output.writeObject(__initialized);
            output.writeObject(__detachedState);
            if (meta::isInitialized()) {
                output.writeObject(_id);
                output.writeObject(_name);
            }
            else {
                output.writeObject(_id);
            }
        }
    }
}]]>
        </programlisting>
            
        <para>
        The recommendations for manual editing are explicit in the header comments of each AS3 classes: while the "Base" class may be regenerated at any time, 
        keeping it sync with its Java model class, the inherited one is only generated when it does not exist and you may safely add custom methods into it.
        </para>
        <para>
        This two files generation principle is used for all generated classes except interface and enum: these classes are generated without any "Base" class 
        and overwritten each time you have modified their Java counterparts.
        </para>
        <warning><para>
        Note: Do not modify manually generated ActionScript3 interface or enum classes !
        </para></warning>

        <para>
        Here are the details for (re)generation conditions:
        </para>
        
        <para>
        Note that for Java classes, relevant timestamp is the last modified time of the .class file, not the .java file.
        
        <informaltable>
            <tgroup cols="2">
                <colspec colnum="1" colwidth="1*" />
                <colspec colnum="2" colwidth="2*" />
                <thead>
                    <row>
                        <entry>Templates</entry>
                        <entry>Conditions for (re)generation</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>Dual templates (base + inherited)</entry>
                        <entry>
                        The inherited AS3 class is generated only once if it does not exist. The AS3 base one is generated if it does not exist 
                        or if its timestamp (last modified time) is less than the Java class one
                        </entry>
                    </row>
                    <row>
                        <entry>Single template (enums or interfaces)</entry>
                        <entry>
                        Like the base condition above, the AS3 class is (re)generated if it does not exist or if its timestamp is less than the Java class one
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </informaltable>
        </para>
	</section>
	
	<section id="gas3.templates">
	   <title>Java Classes and Corresponding Templates</title>
	   <para>
       Here is the summary of templates used by the generator depending on the kind of Java class it encounters:

       <informaltable>
           <tgroup cols="3">
               <colspec colnum="1" colwidth="3*" />
               <colspec colnum="2" colwidth="1*" />
               <colspec colnum="3" colwidth="1*" />
               <thead>
                   <row>
                       <entry>Type of Java Class</entry>
                       <entry>Template</entry>
                       <entry>Base Template</entry>
                   </row>
               </thead>
               <tbody>
                   <row>
                       <entry>Standard Java beans</entry>
                       <entry>bean.gsp</entry>
                       <entry>beanBase.gsp</entry>
                   </row>
                   <row>
                       <entry>JPA entities: all classes annotated with <literal>@Entity</literal> and <literal>@MappedSuperclass</literal></entry>
                       <entry>entity.gsp</entry>
                       <entry>entityBase.gsp</entry>
                   </row>
                   <row>
                       <entry>Java enums</entry>
                       <entry>enum.gsp</entry>
                       <entry>(none)</entry>
                   </row>
                   <row>
                       <entry>Java interfaces</entry>
                       <entry>interface.gsp</entry>
                       <entry>(none)</entry>
                   </row>
                   <row>
                       <entry>Java services: all classes annotated with <literal>@RemoteDestination</literal></entry>
                       <entry>remote.gsp</entry>
                       <entry>remoteBase.gsp</entry>
                   </row>
                   <row>
                       <entry>Java events (CDI): all classes annotated with <literal>@TideEvent</literal></entry>
                       <entry>bean.gsp</entry>
                       <entry>beanBase.gsp</entry>
                   </row>
               </tbody>
           </tgroup>
       </informaltable>
       </para>
       
       <para>
       Note that all these templates are bundled in the granite-generator.jar archive, in the org.granite.generator.template package and accessible as resources via the class loader.
       </para>
	</section>
    
    <section id="gas3.knownlimitations">
       <title>Known Limitations</title>
       <para>
       Gas3 does not support inner classes except of enum type. You must declare your classes in separated source files 
       if you want them to be correctly handled by the generator.
       </para>
       
       <para>
       Gas3 never deletes files, if you have removed or renamed a Java class, the old AS3 class versions must be manually removed.
       </para>
       
       <para>
       Due to the absence of abstract classes in ActionScript 3, some inheritance models cannot be generated correctly.
       </para>
    </section>
	
	<section id="gas3.eclipse">
	   <title>Eclipse Plugin</title>
       <formalpara>
            <title>Installation</title>
            <para>
            Download <literal>org.granite.builder_***.jar</literal> and drop it in your Eclipse <literal>plugins</literal> directory, 
            making sure to remove any older versions. Then, restart Eclipse.
            </para>
       </formalpara>
       
       <formalpara>
            <title>Adding the GraniteDS Nature and Configuration Wizard</title>
            <para>
            The <emphasis>Add GraniteDS Nature</emphasis> is available for any <emphasis>open Java project</emphasis>. 
            When you want to use the builder with your Java project, right-click on the project in your Eclipse package explorer 
            and select <emphasis>Add GraniteDS Nature</emphasis>:
            <imagedata align="center" fileref="images/gb1.jpg"/>   
            </para>
        </formalpara>
        
        <para>
        This action should launch a configuration wizard, whose first step is to select Java source folders 
        for which you code generation (i.e., ActionScript 3 beans that mirror your JavaBeans):
        <imagedata align="center" fileref="images/gb2.jpg"/>   
        </para>

        <para>
        You may select as many Java source folders as you want and configure specific filters and output directories for each of them. 
        Just select one of the <emphasis>Included</emphasis>, <emphasis>Excluded</emphasis>, or <emphasis>Output</emphasis> subnodes 
        and click on the <emphasis>Edit</emphasis> button.
        <imagedata align="center" fileref="images/gb3.jpg"/>   
        </para>

        <para>
        For inclusion/exclusion patterns, the syntax is similar to the Ant include/exclude ones in fileset and the following rules apply:
    
        <itemizedlist>
            <listitem>If you do not configure any exclusion and inclusion patterns, all Java classes in the folder are used for the generation.</listitem>
            <listitem>If a class is matched by an exclusion pattern, it will be ignored even if it is matched by another inclusion pattern.</listitem>
        </itemizedlist>
                
        In the example, <literal>**/*Service*.java</literal> will match any Java class that contains the Service string in its name in any subdirectory.
        </para>

        <para>
        For each selected Java source folder you may also configure specific output directories:
        
        <itemizedlist>
            <listitem>
            <literal>Output Directory</literal>: A directory relative to your project directory where generated ActionsScript3 classes are put.
            </listitem>
            <listitem>
            <literal>Base Output Directory</literal>: An optional directory relative to your project directory where so-called "Base" 
            generated ActionsScript 3 classes are put. If left empty, the output directory above is used for both "Base" and inherited 
            ActionScript 3 classes. See <link linkend="gas3.classes">here</link> for this distinction.            
            </listitem>
        </itemizedlist>
                
        The next step in the wizard allows your Java project dependencies. This is required when your Java classes make references to other classes 
        declared in other Java projects. Clicking on the <emphasis>Add project</emphasis> button will open a dialog that lists all other 
        <emphasis>open Java projects</emphasis>:
        <imagedata align="center" fileref="images/gb4.jpg"/>   
        </para>
        
        <para>
        The next step is classpath configuration. If you do not use any custom classes in the <emphasis>Options</emphasis> panel 
        you do not need to change anything here since the classpath is automatically configured with your current selected source folders. 
        In the following picture, the <literal>helloworld2/bin</literal> directory, where Eclipse compiles your Java source, is preselected, 
        as well as all libraries in the build path, such as <literal>ejb3-persistence.jar</literal> and <literal>jboss-ejb3x.jar</literal>:
        <imagedata align="center" fileref="images/gb5.jpg"/>   
        </para>

        <para>
        The next panel lets you configure custom generation templates. 
        Those templates are a mix of the JSP syntax and the <ulink url="http://groovy.codehaus.org">Groovy language</ulink>. 
        If you need specific code generation, you may write your own template, select one template in the displayed tree, and click on the <emphasis>Edit</emphasis> button:
        <imagedata align="center" fileref="images/gb6.jpg"/>   
        </para>

        <para>
        In the above example, a <literal>class:</literal> protocol is used because all standard templates are available in the classpath. 
        Alternatively, you may use the <literal>file:</literal> protocol to load your template from the filesystem.
        </para>
        
        <para>
        Clicking the <emphasis>Tide</emphasis> button will configure Tide specific templates for entity beans. 
        Use it if you are configuring the builder for a Tide project.
        </para>
        
        <para>
        The last panel lets you configure various options:
        <imagedata align="center" fileref="images/gb7.jpg"/>   
        </para>
        
        <para>
        Some explanations:
        <itemizedlist>
            <listitem>
            <literal>UID Property Name</literal>: If you want your AS3 to implement <literal>mx.core.IUID</literal>, you must tell the generator 
            the name of the Java field that contains this UID; use the same name in all your beans. Default is to search for field named <literal>uid</literal>.
            </listitem>
            <listitem>
            <literal>AS3TypeFactory Class</literal>: You may use this option to configure a custom factory for special type support. 
            See <link linkend="ext.customtypes">Handling Custom Data Types</link> for a detailed example. If you configure this, 
            you must add your class in the <emphasis>Classpath</emphasis> panel.
            </listitem>
            <listitem>
            <literal>EntityFactory Class</literal>: You may use this option to configure a custom factory for special entity support. 
            Setting this field to <literal>org.granite.generator.as3.BVEntityFactory</literal> is useful if you want to use the GraniteDS validation framework. 
            See <link linkend="graniteds.validation">Bean Validation (JSR-303)</link> for details.
            </listitem>
            <listitem>
            <literal>RemoteDestinationFactory Class</literal>: You may use this option to configure a custom factory for special service support. 
            You could for example implement a specific factory to analyze services for a particular framework.
            </listitem>
            <listitem>
            <literal>"Show debug informations in console"</literal>: If enabled, Gas3 will display more information during the generation process.
            </listitem>
            <listitem>
            <literal>"Generate a Flex Builder configuration file"</literal>: If enabled, Gas3 will generate a <literal>flex-config.xml</literal> 
            that may be used in your compiler options. Useful to make sure that all generated AS3 beans will be included in your SWF.
            </listitem>
            <listitem>
            <literal>"Use org.granite.math.Long"</literal>: If enabled, Gas3 will generate AS3 <literal>Long</literal> properties for 
            Java <literal>long</literal> or <literal>Long</literal> properties. See <link linkend="graniteds.bignumber">Big Number Implementations</link> for details.
            </listitem>
            <listitem>
            <literal>"Use org.granite.math.BigInteger"</literal>: If enabled, Gas3 will generate AS3 <literal>BigInteger</literal> properties for 
            Java <literal>BigInteger</literal> properties. See <link linkend="graniteds.bignumber">Big Number Implementations</link> for details.
            </listitem>
            <listitem>
            <literal>"Use org.granite.math.BigDecimal"</literal>: If enabled, Gas3 will generate AS3 <literal>BigDecimal</literal> properties for 
            Java <literal>BigDecimal</literal> properties. See <link linkend="graniteds.bignumber">Big Number Implementations</link> for details.
            </listitem>
        </itemizedlist>
        </para>
        
        <para>
        When you have finished with the wizard, a first generation process will start and you should see something like this in the Eclipse console:
        <imagedata align="center" fileref="images/gb10.jpg"/>   
        </para>

        <formalpara>
            <title>The GraniteDS Project Properties Panel</title>
            <para>
            When you need to change your configuration later, you may right-click on your project, select the <emphasis>Properties</emphasis> item, 
            and you'll be able to modify all GraniteDS Eclipse Builder configuration options:
            
            <imagedata align="center" fileref="images/gb8.jpg"/>

            The panels are exactly the same as those of the wizard and the above documentation applies.
            </para>
        </formalpara>

        <formalpara>
            <title>Using the GraniteDS Builder Together with Flex/Flash Builder</title>
            <para>
            You may use GraniteDS builder with Flex Builder provided that the three builders (Java, Granite, and Flex) are configured in the correct order. 
            It will be ok if you create a Java project, add the Flex project nature, and then the GraniteDS nature; the builder will make sure 
            that builders are set up in the correct order. Otherwise, you may have to change this order. 
            Right-click on your project, select the <emphasis>Properties</emphasis> item, and select the <emphasis>Builders</emphasis> entry:
            
            <imagedata align="center" fileref="images/gb11.jpg"/>

            The order (Java / Granite / Flex) in the above picture is the correct one.
            </para>
        </formalpara>

        <formalpara>
            <title>Removing the GraniteDS Nature</title>
            <para>
            When you have configured your project to use the GraniteDS Eclipse Builder, you may cancel any further generation processes by removing the nature:
            
            <imagedata align="center" fileref="images/gb9.jpg"/>
            
            Note that the hidden configuration file <literal>.granite</literal> in your project is not removed by this action and you must delete it manually. 
            Otherwise, it will be reused whenever you add the nature again.
            </para>
        </formalpara>

        <formalpara>
            <title>Java file deletion / renaming</title>
            <para>
            The main purpose of the builder is to generate AS3 files based on Java sources which are added or modified. When a Java source file
            is deleted or renamed, it will append to the name all potentially AS3 generated files a suffix composed of a dot, the current system millisecond
            since epoch (1/1/1970) and an additionnal extension ".hid". The idea behind these renaming operations is to make sure that the Flex
            compilation will detect errors if these classes are used in the project (easing refactoring) and to ensure that any manual editing you have made
            in these classes is recoverable.
            </para>
        </formalpara>
	</section>
	
	<section id="gas3.ant">
	   <title>Ant Task</title>
	   <formalpara>
	       <title>Installation in Eclipse</title>
	       <para>
           Download <literal>org.granite.builder_***.jar</literal>, and drop it in your Eclipse <literal>plugins</literal> directory 
           (remove any older version and restart Eclipse). The <emphasis>Add GraniteDS Nature</emphasis> option should now be available 
           if you right-click on your Java project and the <literal>gas3</literal> Ant task should be ready to use in your <literal>build.xml</literal> file under Eclipse.
	       </para>
	   </formalpara>
	   
	   <formalpara>
	       <title>Standalone Installation</title>
	       <para>
           Download <literal>org.granite.builder_***.jar</literal> and unzip it somewhere (create a new directory, this jar doesn't contain a root folder).
           Move the <literal>lib</literal> directory somewhere else (say <literal>gas3libs</literal> at the root of you harddrive).
           </para>
           
           <para>
           In your <literal>build.xml</literal>, you must declare the Gas3 ant task as follows:
	       </para>
	   </formalpara>
	   
	   <programlisting role="XML">
<![CDATA[<taskdef name="gas3" classname="org.granite.generator.ant.AntJavaAs3Task"/>]]>
	   </programlisting>

        <para>
        To launch a build process with Gas3 targets, you should go to your Java source root directory and type something like:
        </para>

       <programlisting>
$ ant -lib /gas3libs -f build.xml {target}
...
       </programlisting>

        <para>
        Just replace {target} with a valid target name and make sure Ant is correctly set up: set <literal>ANT_HOME</literal> variable 
        and put <literal>&lt;ANT_HOME&gt;/bin</literal> in your <literal>PATH</literal> environment variable.
        </para>

        <formalpara>
            <title>Basic Usage</title>
            <para>
            After installation, you may use the Gas3 Ant task in any target of an Ant build file. 
            A working example of Gas3 usage is available in the <literal>examples/graniteds_ejb3</literal> sample application.
            </para>

            <para>
            For example:
            </para>
        </formalpara>

        <programlisting role="XML">
<![CDATA[<target name="generate.as3">
    <gas3 outputdir="as3">
        <classpath>
            <pathelement location="classes"/>
        </classpath>
        <fileset dir="classes">
            <include name="com/myapp/entity/**/*.class"/>
        </fileset>
    </gas3>
</target>]]>
        </programlisting>
        
        <para>
        As you can notice, Gas3 generates AS3 beans from Java compiled classes. 
        You may use multiple Ant filesets in order to specify for which JPA classes you want to generate AS3 beans. 
        The <literal>classpath</literal> node is used for fileset class loading, and you may reference extra jars or classes needed by your beans class loading.
        </para>

        <para>
        The <literal>outputdir</literal> attribute lets you instruct Gas3 in which directory AS3 beans will be generated (e.g., <literal>./as3</literal>). 
        This path is relative to your current project directory and Gas3 will create subdirectories for packages. 
        AS3 beans will by default have the same package hierarchy as Java classes, with the same subdirectories as well.
        </para>

        <para>
        For each JPA entity (say <literal>com.myapp.entity.MyEntity</literal>), Gas3 will generate two AS3 beans:
        <itemizedlist>
            <listitem>
            <literal>org.entity.MyEntityBase.as</literal>: This bean mainly contains fields, getters, setters, and <literal>IExternalizable</literal> methods 
            (<literal>readExternal</literal>/<literal>writeExternal</literal>). This file is generated if it does not exist or if it is outdated.
            </listitem>
            <listitem>
            <literal>org.entity.MyEntity.as</literal>: This bean inherits from the "Base" one and is only generated if it does not exist.
            </listitem>
        </itemizedlist>
        While you should not modify the "Base" file, since your modifications may be lost after another generation process, 
        you may safely add your code to the inherited bean.
        </para>

        <para>
        You can also use Ant <literal>zipfileset</literal>s if you want to generate AS3 classes from an existing jar. Note that
        the jar must be in the classpath:
        </para>

        <programlisting role="XML">
<![CDATA[<target name="generate.as3">
    <gas3 outputdir="as3">
        <classpath>
            <pathelement location="lib/myclasses.jar"/>
        </classpath>
        <zipfileset src="lib/myclasses.jar">
            <include name="com/myapp/entity/**/*.class"/>
        </zipfileset>
    </gas3>
</target>]]>
        </programlisting>

        <formalpara>
            <title>Packages Translations</title>
            <para>
            You may tell Gas3 to generate AS3 classes with a different package and directory structure than the corresponding Java classes ones.
            </para>
        </formalpara>
        
        <programlisting role="XML">
<![CDATA[<gas3 ...>
    <classpath .../>
    <fileset .../>

    <translator
        java="path.to.my.java.class"
        as3="path.to.my.as3.class" />
    <translator
        java="path.to.my.java.class.special"
        as3="otherpath.to.my.as3.class.special" />
  ...
</gas3>]]>
        </programlisting>
        
        <para>
        Gas3 uses these translators with a "best match" principle; all Java classes within the <literal>path.to.my.java.class</literal> package, 
        and subpackages as well, will be translated to <literal>path.to.my.as3.class</literal>, while <literal>path.to.my.java.class.special</literal> 
        will use a specific translation (<literal>otherpath.to.my.as3.class.special</literal>).
        </para>

        <note><para>
        If you use a special <literal>Java2As3</literal> converter, you must take care of packages translations. 
        See <literal>org.granite.generator.as3.DefaultJava2As3</literal> implementation for details.
        </para></note>

        <formalpara>
            <title>Groovy Templates</title>
            <para>
            Gas3 generation relies on Groovy templates. You may plug your own templates in by using one of the advanced options attributes below. 
            For example, you could add a <literal>entitytemplate="/absolute/path/to/my/groovy/entityTemplate.gsp"</literal> attribute to the <literal>gas3</literal> node. 
            If you want to see the Groovy code of the default templates, just unpack <literal>granite-generator.jar</literal> 
            in the <literal>lib</literal> directory of the plugin, and look for <literal>org/granite/generator/template/*[Base].gsp</literal> files.
            </para>
        </formalpara>
        
        <formalpara>
            <title>Advanced Options (Gas3 XML Attributes)</title>
            <para>
			Here is the complete list of Gas3 node attributes:
			
			<itemizedlist>
			     <listitem>
                 <literal>outputdir</literal> and <literal>baseoutputdir</literal>: We have already seen the <literal>outputdir</literal> attribute 
                 in basic usage. <literal>baseoutputdir</literal> lets you define a custom output directory for your "Base" generated files.
                 The default is to use the same directory as specified by the <literal>outputdir</literal> attribute.
			     </listitem>
                 <listitem>
                 <literal>uid</literal>: If you want your AS3 to implement <literal>mx.core.IUID</literal>, you must tell the generator 
                 the name of the Java field that contains this UID. By default, Gas3 will search for a field named <literal>uid</literal>. 
                 You may change this by adding a <literal>uid="myUid"</literal> attribute to the <literal>gas3</literal> node. 
                 If Gas3 does not find this <literal>uid</literal>, it will be silently ignored.
                 </listitem>
                 <listitem>
                 <literal>tide</literal>: Should we use a Tide specific template instead of the standard base template used for entity beans 
                 (<literal>true</literal> or <literal>false</literal>, defaut is <literal>false</literal>). Setting this attribute has no effect 
                 if you use a custom entity base template. See below.
                 </listitem>
                 <listitem>
                 <literal>entitytemplate</literal> and <literal>entitybasetemplate</literal>: Templates used for classes annotated with 
                 <literal>@Entity</literal> or <literal>@MappedSuperclass</literal>.
                 </listitem>
                 <listitem>
                 <literal>interfacetemplate</literal>: Template used for Java interfaces.
                 </listitem>
                 <listitem>
                 <literal>beantemplate</literal> and <literal>beanbasetemplate</literal>: Templates used for other Java classes including <literal>@Embeddable</literal>.
                 </listitem>
                 <listitem>
                 <literal>enumtemplate</literal>: Template used for <literal>java.lang.Enum</literal> types.
                 </listitem>
                 <listitem>
                 <literal>remotetemplate</literal> and <literal>remotebasetemplate</literal>: Templates used for server services (EJB3, Spring or Seam services).
                 </listitem>
                 <listitem>
                 <literal>as3typefactory</literal>: You can plug your own <literal>org.granite.generator.as3.As3TypeFactory</literal> implementation 
                 in order to add support for custom types. For example, if you have configured a custom Joda time converter, 
                 you may extend Gas3 accordingly for this custom type. Just extend the <literal>org.granite.generator.as3.DefaultAs3TypeFactory</literal> class 
                 and return <literal>org.granite.generator.as3.As3Type.DATE</literal> when you encounter a Joda <literal>DateTime</literal> instance. 
                 See <link linkend="ext.customtypes">Handling Custom Data Types</link> for a detailed example.
                 </listitem>
                 <listitem>
                 <literal>entityfactory</literal>: Class used to introspect specific entity properties or metadata (default is 
                 <literal>org.granite.generator.as3.DefaultEntityFactory</literal>). 
                 You may also use the built-in <literal>org.granite.generator.as3.BVEntityFactory</literal> in order to replicate bean validation annotations 
                 into your AS3 model <link linkend="graniteds.validation">Bean Validation (JSR-303)</link>.
                 </listitem>
                 <listitem>
                 <literal>remotedestinationfactory</literal>: Class used to introspect specific service properties or metadata (default 
                 is <literal>org.granite.generator.as3.DefaultRemoteDestinationFactory</literal>).
                 </listitem>
                 <listitem>
                 <literal>transformer</literal>: Class used to control the generation process (very advanced use).
                 </listitem>
                 <listitem>
                 <literal>externalizelong</literal>: should we write AS3 <literal>Long</literal> variables 
                 (see <link linkend="graniteds.bignumber">Big Number Implementations</link>). Default is <literal>false</literal>.
                 </listitem>
                 <listitem>
                 <literal>externalizebiginteger</literal>: should we write AS3 <literal>BigInteger</literal> variables
                 (see <link linkend="graniteds.bignumber">Big Number Implementations</link>). Default is <literal>false</literal>.
                 </listitem>
                 <listitem>
                 <literal>externalizebigdecimal</literal>: should we write AS3 <literal>BigDecimal</literal> variables
                 (see <link linkend="graniteds.bignumber">Big Number Implementations</link>). Default is <literal>false</literal>.
                 </listitem>
			</itemizedlist>
            </para>
            
            <para>
            For example:
            </para>
        </formalpara>

        <programlisting role="XML">
<![CDATA[<target name="generate.as3">
    <gas3
        outputdir="as3"
        baseoutputdir="base_as3"
        uid="myUidFieldName"
        entitytemplate="/myEntityTemplate.gsp"
        entitybasetemplate="/myEntityBaseTemplate.gsp"
        interfacetemplate="/myInterfaceTemplate.gsp"
        beantemplate="/myBeanTemplate.gsp"
        beanbasetemplate="/myBeanBaseTemplate.gsp">
        enumtemplate="/myEnumTemplate.gsp"
        remotetemplate="/myRemoteTemplate.gsp"
        remotebasetemplate="/myRemoteBaseTemplate.gsp"
        tide="true"
        as3typefactory="path.to.MyAs3TypeFactory"
        entityfactory="path.to.MyEntityFactory"
        remotedestinationfactory="path.to.MyRDFactory"
        transformer="path.to.MyTransformer"
        externalizelong="true"
        externalizebiginteger="true"
        externalizebigdecimal="true">
        <classpath>
            <pathelement location="classes"/>
        </classpath>
        <fileset dir="classes">
            <include name="test/granite/ejb3/entity/**/*.class"/>
        </fileset>
    </gas3>
</target>]]>
        </programlisting>
        
        <para>
        Note that when using a custom <literal>as3typefactory</literal>, <literal>entityfactory</literal>, <literal>remotedestinationfactory</literal> 
        or <literal>transformer</literal> attribute, you must configure the classpath in order to make your custom class available to the Gas3 engine; 
        either use the classpath attribute in the <literal>taskdef</literal> declaration or in the <literal>gas3</literal> call.
        </para>
	</section>
	
	<section id="gas3.maven">
	   <title>Maven Plugin (Flexmojos)</title>
	   <para>
	   The Gas3 generator is used as the default code generation tool in the Flexmojos plugin. To use it, you need to add the following part to your maven POM : 
	   </para>
	   <programlisting role="XML">
<![CDATA[<build>
    ...
    <pluginManagement>
        <plugins>
            <plugin>
                <groupId>org.sonatype.flexmojos</groupId>
                <artifactId>flexmojos-maven-plugin</artifactId>
                <version>${flexmojos.version}</version>
            </plugin>
        </plugins>
    </pluginManagement>
    
    <plugins>
        <plugin>
            <groupId>org.sonatype.flexmojos</groupId>
            <artifactId>flexmojos-maven-plugin</artifactId>
            <version>${flexmojos.version}</version>
            <extensions>true</extensions>
            <executions>
                <execution>
                    <goals>
                        <goal>generate</goal>
                    </goals>
                    <configuration>
                        <generatorToUse>graniteds21</generatorToUse>
                        <baseOutputDirectory>${project.build.directory}/generated-sources</baseOutputDirectory>
                        <outputDirectory>${project.build.directory}/../src/main/flex</outputDirectory>
                        <extraOptions>
                            <tide>true</tide>
                            <uid>uid</uid>
                            <entityFactory>org.granite.generator.as3.BVEntityFactory</entityFactory>
                            <outputEnumToBaseOutputDirectory>false</outputEnumToBaseOutputDirectory>
                        </extraOptions>
                        <includeJavaClasses>
                            <include>${package}.entities.**</include>
                            <include>${package}.services.*Service</include>
                        </includeJavaClasses>
                    </configuration>
                </execution>
            </executions>
            <dependencies>
                <dependency>
                    <groupId>javax.persistence</groupId>
                    <artifactId>persistence-api</artifactId>
                    <version>1.0</version>
                </dependency> 
                <dependency>
                    <groupId>javax.validation</groupId>
                    <artifactId>validation-api</artifactId>
                    <version>1.0.0.GA</version>
                </dependency> 
                <dependency>
                    <groupId>javax.jdo</groupId>
                    <artifactId>jdo2-api</artifactId>
                    <version>2.3-eb</version>
                </dependency>
                <dependency>
                    <groupId>org.codehaus.groovy</groupId>
                    <artifactId>groovy</artifactId>
                    <version>1.6.0</version>
                </dependency> 
                <dependency>
                    <groupId>antlr</groupId>
                    <artifactId>antlr</artifactId>
                    <version>2.7.7</version>
                </dependency>     
                <dependency>
                    <groupId>asm</groupId>
                    <artifactId>asm</artifactId>
                    <version>2.2.3</version>
                </dependency> 
                <dependency>
                    <groupId>com.thoughtworks.xstream</groupId>
                    <artifactId>xstream</artifactId>
                    <version>1.2.2</version>
                </dependency> 
                <dependency>
                    <groupId>org.graniteds</groupId>
                    <artifactId>granite-core</artifactId>
                    <version>${graniteds.version}</version>
                </dependency>
                <dependency>
                    <groupId>org.graniteds</groupId>
                    <artifactId>granite-generator-share</artifactId>
                    <version>${graniteds.version}</version>
                </dependency>
                <dependency>
                    <groupId>org.graniteds</groupId>
                    <artifactId>granite-generator</artifactId>
                    <version>${graniteds.version}</version>
                </dependency>
            </dependencies>
        </plugin>
        ...
    </plugins>
    ...
</build>]]>
	   </programlisting>
	</section>
	
	<section id="gas3.templatelanguage">
	   <title>Template Language</title>
	   <para>
        Gas3 templates are based on a specific implementation of <ulink url="http://groovy.codehaus.org/Groovy+Templates">Groovy Templates</ulink>. 
        As such, all Groovy template documentation should apply.
        </para>
        
        <para>
        The reason why the standard Groovy implementation was not used was the lack of comments support (<literal>&lt;%-- ... --%&gt;</literal>) 
        and some formatting issues, especially with platform specific carriage returns. This may now be fixed but it was not at that time.
        </para>
        
        <para>
        While the language itself is already documented on Groovy site, there are two specific bindings (i.e., global variables used in Gas3 templates) 
        that should be referenced.
        </para>
        
        <para>
        Template execution is a two-phase process. First, the template is transformed to a standard Groovy script (mainly with expressions 
        like <literal>print(...));</literal> second, the Groovy script is compiled and executed. Of course, the result of the first transformation 
        and the compiled script is cached, so further executions with the same template are much faster.	   
        </para>
        
        <formalpara>
            <title>Template Bindings</title>
            <para>
            There are two bindings available in Gas3 templates:
            
            <informaltable>
	            <tgroup cols="3">
	                <colspec colnum="1" colwidth="1*" />
	                <colspec colnum="2" colwidth="2*" />
	                <colspec colnum="3" colwidth="3*" />
	                <thead>
	                    <row>
	                        <entry>Name</entry>
	                        <entry>Type</entry>
                            <entry>Description</entry>
	                    </row>
	                </thead>
	                <tbody>
	                    <row>
	                        <entry><literal>gVersion</literal></entry>
	                        <entry><literal>String</literal></entry>
	                        <entry>Version number of the generator, e.g., "2.0.0"</entry>
	                    </row>
                        <row>
                            <entry><literal>jClass</literal></entry>
                            <entry>Implementation of the <literal>JavaType</literal> interface</entry>
                            <entry>An object describing the Java class for which the generator is writting an ActionScript 3 class</entry>
                        </row>
	                </tbody>
	            </tgroup>
            </informaltable>
            Possible implementations of the above JavaType interface are:
            <informaltable>
                <tgroup cols="2">
                    <colspec colnum="1" colwidth="1*" />
                    <colspec colnum="2" colwidth="5*" />
                    <thead>
                        <row>
                            <entry>Type</entry>
                            <entry>Description</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><literal>JavaEntityBean</literal></entry>
                            <entry>
                            Class that describes an JPA entity bean (i.e., a class annotated with a <literal>@Entity</literal> or a 
                            <literal>@MappedSuperclass</literal> persistence annotation)
                            </entry>
                        </row>
                        <row>
                            <entry><literal>JavaEnum</literal></entry>
                            <entry>
                            Class that describes a Java <literal>enum</literal> class
                            </entry>
                        </row>
                        <row>
                            <entry><literal>JavaInterface</literal></entry>
                            <entry>
                            Class that describes a Java interface
                            </entry>
                        </row>
                        <row>
                            <entry><literal>JavaBean</literal></entry>
                            <entry>
                            Class that describes all other Java classes
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </informaltable>
            </para>
            <para>
            Those two bindings may be used in your templates as any other variables. For example:
            </para>
        </formalpara>
        
        <programlisting role="AS3">// Generated by Gas3 v.${gVersion}.

package ${jClass.as3Type.packageName} {

    public class ${jClass.as3Type.name} {
        ...
    }
}
        </programlisting>
        
        <para>
        If you execute this template with Gas3 2.2.0 and Java class named <literal>com.myapp.MyClass</literal>, the output will be:
        </para>
        
        <programlisting role="AS3">// Generated by Gas3 v.2.2.0.

package com.myapp {

    public class MyClass {
        ...
    }
}        
        </programlisting>
        
        <para>
        If you plan to write custom templates, you should have a look at the standard GraniteDS templates and API documentation of the four <literal>JavaType</literal>
        implementations listed above.        
        </para>  

        <formalpara>
            <title>Sample Template</title>
            <para>
            Let's have a look to the standard GraniteDS template for Java interfaces. 
            You may also see all templates <ulink url="https://github.com/graniteds/graniteds_builder/tree/master/src/org/granite/generator/template">here</ulink>:
            </para>
        </formalpara>
        
        <programlisting role="JAVA">
<![CDATA[<%--
  GRANITE DATA SERVICES
  Copyright (C) 2007-2008 ADEQUATE SYSTEMS SARL

  This file is part of Granite Data Services.

  Granite Data Services is free software; you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published by
  the Free Software Foundation; either version 3 of the License, or (at your
  option) any later version.

  Granite Data Services is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License
  for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this library; if not, see <http://www.gnu.org/licenses/>.
--%><%
    Set as3Imports = new TreeSet();

    for (jImport in jClass.imports) {
        if (jImport.as3Type.hasPackage() &&
jImport.as3Type.packageName != jClass.as3Type.packageName)
            as3Imports.add(jImport.as3Type.qualifiedName);
    }

%>/**
 * Generated by Gas3 v${gVersion} (Granite Data Services).
 *
 * WARNING: DO NOT CHANGE THIS FILE. IT MAY BE OVERWRITTEN EACH TIME YOU USE
 * THE GENERATOR. INSTEAD, EDIT THE INHERITED INTERFACE (${jClass.as3Type.name}.as).
 */

package ${jClass.as3Type.packageName} {<%

    ///////////////////////////////////////////////////////////////////////////
    // Write Import Statements.

    if (as3Imports.size() > 0) {%>
<%
    }
    for (as3Import in as3Imports) {%>
    import ${as3Import};<%
    }

    ///////////////////////////////////////////////////////////////////////////
    // Write Interface Declaration.%>

    public interface ${jClass.as3Type.name}Base<%

    if (jClass.hasSuperInterfaces()) {
        %> extends <%
        boolean first = true;
        for (jInterface in jClass.superInterfaces) {
            if (first) {
                first = false;
            } else {
                %>, <%
            }
            %>${jInterface.as3Type.name}<%
        }
    }

    %> {<%

    ///////////////////////////////////////////////////////////////////////////
    // Write Public Getter/Setter.

    for (jProperty in jClass.properties) {

        if (jProperty.readable || jProperty.writable) {%>
<%
            if (jProperty.writable) {%>
        function set ${jProperty.name}(value:${jProperty.as3Type.name}):void;<%
            }
            if (jProperty.readable) {%>
        function get ${jProperty.name}():${jProperty.as3Type.name};<%
            }
        }
    }%>
    }
}]]>
        </programlisting>
        
        <para>
        The code for this template is rather simple, but it can be very tricky to distinguish between JSP-like expressions, Groovy code, and outputted ActionScript 3 code.
        </para>
        <para>
        The first block, enclosed with <literal>&lt;%-- --%&gt;</literal>, is a template comment: it will be completely ignored at transformation 
        (Groovy template to Groovy script) time.
        </para>
        <para>
        The second block, enclosed with <literal>&lt;% %&gt;</literal>, is plain Groovy code and will be outputed as is at transformation time. 
        Its purpose is to collect and sort all references to other classes so we can later write ActionScript 3 <literal>import</literal> statements.
        </para>
        <para>
        Then, the ActionsScript 3 code template really begins with a comment (Gas3 version and warning) and is followed by a package and interface 
        definition with superinterfaces, if any, and finally, by a loop over interface getters/setters. Note that comments like:
        </para>
        
        <programlisting role="AS3">
<![CDATA[///////////////////////////////////////////////////////////////////////////
// Write Import Statements.]]>
        </programlisting>
        
        <para>
        ... are Groovy script comments. They will be in the Groovy script but you will not find them in the outputted ActionScript3 file.
        </para>
        <para>
        After the first transformation (Groovy template to Groovy script), the rendered code will be as follows:
        </para>
        
        <programlisting role="JAVA">
<![CDATA[    Set as3Imports = new TreeSet();

    for (jImport in jClass.imports) {
        if (jImport.as3Type.hasPackage() &&
jImport.as3Type.packageName != jClass.as3Type.packageName)
            as3Imports.add(jImport.as3Type.qualifiedName);
    }


print("/**\n");
print(" * Generated by Gas3 v${gVersion} (Granite Data Services).\n");
print(" *\n");
print(" * WARNING: DO NOT CHANGE THIS FILE. IT MAY BE OVERWRITTEN EACH TIME YOU USE\n");
print(" * THE GENERATOR. INSTEAD, EDIT THE INHERITED INTERFACE
(${jClass.as3Type.name}.as).\n");
print(" */\n");
print("\n");
print("package ${jClass.as3Type.packageName} {");


    ///////////////////////////////////////////////////////////////////////////
    // Write Import Statements.

    if (as3Imports.size() > 0) {
print("\n");

    }
    for (as3Import in as3Imports) {
print("\n");
print("    import ${as3Import};");

    }

    ///////////////////////////////////////////////////////////////////////////
    // Write Interface Declaration.
print("\n");
print("\n");
print("    public interface ${jClass.as3Type.name}Base");


    if (jClass.hasSuperInterfaces()) {
        
print(" extends ");

        boolean first = true;
        for (jInterface in jClass.superInterfaces) {
            if (first) {
                first = false;
            } else {
    
print(", ");

            }

print("${jInterface.as3Type.name}");

        }
    }

    
print(" {");


    ///////////////////////////////////////////////////////////////////////////
    // Write Public Getter/Setter.

    for (jProperty in jClass.properties) {

        if (jProperty.readable || jProperty.writable) {
print("\n");

            if (jProperty.writable) {
print("\n");
print("        function set ${jProperty.name}(value:${jProperty.as3Type.name}):void;");

            }
            if (jProperty.readable) {
print("\n");
print("        function get ${jProperty.name}():${jProperty.as3Type.name};");

            }
        }
    }
print("\n");
print("    }\n");
print("}");
        </programlisting>
        
        <para>
        As you can notice, <literal>${...}</literal> expressions are resolved by the Groovy engine rather than the JSP-like engine. 
        It would have been possible to use expressions like <literal>&lt;%= ... %&gt;</literal>, that will result in a script where:
        </para>
        
        <programlisting role="JAVA">
print("package ${jClass.as3Type.packageName} {");
        </programlisting>
        
        <para>
        .. would have been split into three lines:
        </para>
        
        <programlisting role="JAVA">
print("package ");
print(jClass.as3Type.packageName);
print(" {");
        </programlisting>
        
        <para>
        This is just informative, as it does not change anything in the final result.
        </para>
        <para>
        Then, for this Java source code:
        </para>
        
        <programlisting role="JAVA">
package com.myapp.entity.types;

public interface NamedEntity {

    public String getFirstName();
    public void setFirstName(String firstName);

    public String getLastName();
    public void setLastName(String lastName);

    public String getFullName();
}]]>
        </programlisting>
        
        <para>
        ... you will get this output:
        </para>
        
        <programlisting role="AS3">
<![CDATA[/**
 * Generated by Gas3 v2.2.0 (Granite Data Services).
 *
 * WARNING: DO NOT CHANGE THIS FILE. IT MAY BE OVERWRITTEN EACH TIME YOU USE
 * THE GENERATOR. INSTEAD, EDIT THE INHERITED INTERFACE (NamedEntity.as).
 */

package com.myapp.entity.types {

    public interface NamedEntityBase {

        function set firstName(value:String):void;
        function get firstName():String;

        function get fullName():String;

        function set lastName(value:String):void;
        function get lastName():String;
    }
}]]>
        </programlisting>
        
        <formalpara>
            <title>Template Compilation and Execution Errors</title>
            <para>
            Because of the two transformation steps of the template (Groovy template to Groovy script source, then Groovy script source 
            to <emphasis>pre-compiled</emphasis> Groovy script), there are two possible sources of error:
            
            <itemizedlist>
                <listitem>
                JSP-like syntax errors (first transformation): e.g., unclosed <literal>&lt;%</literal> expression.
                </listitem>
                <listitem>
                Groovy syntax errors (second transformation): e.g., <literal>now TreeSet()</literal>; instead of <literal>new TreeSet();</literal>
                </listitem>
            </itemizedlist>
            </para>

            <para>
            However, since Groovy is an interpreted language, you may get some other errors at execution time:
            <itemizedlist>
                <listitem>
                Mispelled expressions: e.g., <literal>jClass.neme</literal> instead of <literal>jClass.name</literal>.
                </listitem>
                <listitem>
                Runtime exceptions: e.g., 0 / 0.
                </listitem>
            </itemizedlist>
            </para>
            
            <para>
            Whenever these kinds of errors occur, you'll find comprehensive error log in your Shell or Eclipse console.
            </para>
            <para>
            Note that when the error occurs after the first transformation, the Groovy script is printed with line numbers, 
            as well as the Groovy compiler message. It is easy to find the erroneous line in the printed Groovy script, 
            but you have to figure out the corresponding line in the original template:
            </para>            
        </formalpara>
        
        <programlisting role="SHELL">
<![CDATA[[gas3]   Generating: /dev/workspace/graniteds_ejb3/as3/com/myapp/entity/types/NamedEntityBase.as (output file is outdated)
[gas3] org.granite.generator.exception.TemplateCompilationException:Could not compile template: /interfaceBase.gsp
[gas3]    1 | 
[gas3]    2 |     Set as3Imports = now TreeSet();
[gas3]    3 | 
[gas3]    4 |     for (jImport in jClass.imports) {
[gas3]    5 |         if (jImport.as3Type.hasPackage() && jImport.as3Type.packageName != jClass.as3Type.packageName)
[gas3]    6 |             as3Imports.add(jImport.as3Type.qualifiedName);
[gas3]    7 |     }
[gas3]    8 | 
[gas3]    9 | 
[gas3]   10 | print("/**\n");
[gas3]   11 | print(" * Generated by Gas3 v${gVersion} (Granite Data Services).\n");
[gas3]   12 | print(" *\n");
[gas3]   13 | print(" * WARNING: DO NOT CHANGE THIS FILE. IT MAY BE OVERWRITTEN EACH TIME YOU USE\n");
[gas3]   14 | print(" * THE GENERATOR. INSTEAD, EDIT THE INHERITED INTERFACE (${jClass.as3Type.name}.as).\n");
[gas3]   15 | print(" */\n");
[gas3]   16 | print("\n");
[gas3]   17 | print("package ${jClass.as3Type.packageName} {");
[gas3]   18 | 
[gas3]   19 | 
[gas3]   20 |     ///////////////////////////////////////////////////////////////////////////
[gas3]   21 |     // Write Import Statements.
[gas3]   22 | 
[gas3]   23 |     if (as3Imports.size() > 0) {
[gas3]   24 | print("\n");
[gas3]   25 | 
[gas3]   26 |     }
[gas3]   27 |     for (as3Import in as3Imports) {
[gas3]   28 | print("\n");
[gas3]   29 | print("    import ${as3Import};");
[gas3]   30 | 
[gas3]   31 |     }
[gas3]   32 | 
[gas3]   33 |     ///////////////////////////////////////////////////////////////////////////
[gas3]   34 |     // Write Interface Declaration.
[gas3]   35 | print("\n");
[gas3]   36 | print("\n");
[gas3]   37 | print("    public interface ${jClass.as3Type.name}Base");
[gas3]   38 | 
[gas3]   39 | 
[gas3]   40 |     if (jClass.hasSuperInterfaces()) {
[gas3]   41 |       
[gas3]   42 | print(" extends ");
[gas3]   43 | 
[gas3]   44 |       boolean first = true;
[gas3]   45 |       for (jInterface in jClass.superInterfaces) {
[gas3]   46 |           if (first) {
[gas3]   47 |               first = false;
[gas3]   48 |           } else {
[gas3]   49 |               
[gas3]   50 | print(", ");
[gas3]   51 | 
[gas3]   52 |           }
[gas3]   53 |           
[gas3]   54 | print("${jInterface.as3Type.name}");
[gas3]   55 | 
[gas3]   56 |       }
[gas3]   57 |     }
[gas3]   58 | 
[gas3]   59 |     
[gas3]   60 | print(" {");
[gas3]   61 | 
[gas3]   62 | 
[gas3]   63 |     ///////////////////////////////////////////////////////////////////////////
[gas3]   64 |     // Write Public Getter/Setter.
[gas3]   65 | 
[gas3]   66 |     for (jProperty in jClass.properties) {
[gas3]   67 | 
[gas3]   68 |         if (jProperty.readable || jProperty.writable) {
[gas3]   69 | print("\n");
[gas3]   70 | 
[gas3]   71 |             if (jProperty.writable) {
[gas3]   72 | print("\n");
[gas3]   73 | print("        function set ${jProperty.name}(value:${jProperty.as3Type.name}):void;");
[gas3]   74 | 
[gas3]   75 |             }
[gas3]   76 |             if (jProperty.readable) {
[gas3]   77 | print("\n");
[gas3]   78 | print("        function get ${jProperty.name}():${jProperty.as3Type.name};");
[gas3]   79 | 
[gas3]   80 |             }
[gas3]   81 |         }
[gas3]   82 |     }
[gas3]   83 | print("\n");
[gas3]   84 | print("    }\n");
[gas3]   85 | print("}");
[gas3] 
[gas3]  at org.granite.generator.gsp.GroovyTemplate.compile(GroovyTemplate.java:143)
[gas3]  at org.granite.generator.gsp.GroovyTemplate.execute(GroovyTemplate.java:157)
[gas3]  at org.granite.generator.as3.JavaAs3GroovyTransformer.generate(JavaAs3GroovyTransformer.java:119)
[gas3]  at org.granite.generator.as3.JavaAs3GroovyTransformer.generate(JavaAs3GroovyTransformer.java:1)
[gas3]  at org.granite.generator.Transformer.generate(Transformer.java:71)
[gas3]  at org.granite.generator.Generator.generate(Generator.java:83)
[gas3]  at org.granite.generator.ant.AntJavaAs3Task.execute(AntJavaAs3Task.java:327)
[gas3]  at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:288)
[gas3]  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
[gas3]  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
[gas3]  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
[gas3]  at java.lang.reflect.Method.invoke(Method.java:597)
[gas3]  at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:105)
[gas3]  at org.apache.tools.ant.Task.perform(Task.java:348)
[gas3]  at org.apache.tools.ant.Target.execute(Target.java:357)
[gas3]  at org.apache.tools.ant.Target.performTasks(Target.java:385)
[gas3]  at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1329)
[gas3]  at org.apache.tools.ant.Project.executeTarget(Project.java:1298)
[gas3]  at org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)
[gas3]  at org.eclipse.ant.internal.ui.antsupport.EclipseDefaultExecutor.executeTargets(EclipseDefaultExecutor.java:32)
[gas3]  at org.apache.tools.ant.Project.executeTargets(Project.java:1181)
[gas3]  at org.eclipse.ant.internal.ui.antsupport.InternalAntRunner.run(InternalAntRunner.java:423)
[gas3]  at org.eclipse.ant.internal.ui.antsupport.InternalAntRunner.main(InternalAntRunner.java:137)
[gas3] Caused by: org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed,Script1.groovy: 2: expecting EOF, found 'TreeSet' @ line 2, column 26.
[gas3] 1 error]]>
        </programlisting>
        
        <para>
        The error at line 2, column 26 is:
        </para>
        
        <programlisting role="SHELL">
[gas3] 2 | Set as3Imports = now TreeSet();
        </programlisting>

        <para>
        Finding the corresponding line in the original template should be straightforward.
        </para>
	</section>
</chapter>
